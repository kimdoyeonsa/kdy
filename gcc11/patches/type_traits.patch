--- a/libstdc++-v3/include/std/type_traits	2022-02-25 20:15:03.435526761 +0900
+++ b/libstdc++-v3/include/std/type_traits	2022-02-25 20:15:17.423590975 +0900
@@ -966,9 +961,47 @@
 	"template argument must be a complete class or an unbounded array");
     };
 
+  template<bool, typename _Tp, typename... _Args>
+    struct __is_nt_constructible_impl
+    : public false_type
+    { };
+
+  template<typename _Tp, typename... _Args>
+    struct __is_nt_constructible_impl<true, _Tp, _Args...>
+    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
+    { };
+
+  template<typename _Tp, typename _Arg>
+    struct __is_nt_constructible_impl<true, _Tp, _Arg>
+    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
+    { };
+
+  template<typename _Tp>
+    struct __is_nt_constructible_impl<true, _Tp>
+    : public __bool_constant<noexcept(_Tp())>
+    { };
+
+  template<typename _Tp, size_t _Num>
+    struct __is_nt_constructible_impl<true, _Tp[_Num]>
+    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
+    { };
+
+#if __cpp_aggregate_paren_init
+  template<typename _Tp, size_t _Num, typename _Arg>
+    struct __is_nt_constructible_impl<true, _Tp[_Num], _Arg>
+    : public __is_nt_constructible_impl<true, _Tp, _Arg>
+    { };
+
+  template<typename _Tp, size_t _Num, typename... _Args>
+    struct __is_nt_constructible_impl<true, _Tp[_Num], _Args...>
+    : public __and_<__is_nt_constructible_impl<true, _Tp, _Args>...>
+    { };
+#endif
+
   template<typename _Tp, typename... _Args>
     using __is_nothrow_constructible_impl
-      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
+      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
+				   _Tp, _Args...>;
 
   /// is_nothrow_constructible
   template<typename _Tp, typename... _Args>
@@ -982,7 +1015,7 @@
   /// is_nothrow_default_constructible
   template<typename _Tp>
     struct is_nothrow_default_constructible
-    : public __bool_constant<__is_nothrow_constructible(_Tp)>
+    : public __is_nothrow_constructible_impl<_Tp>::type
     {
       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 	"template argument must be a complete class or an unbounded array");
@@ -1083,8 +1116,15 @@
     };
 
   template<typename _Tp, typename _Up>
-    using __is_nothrow_assignable_impl
-      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
+    struct __is_nt_assignable_impl
+    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
+    { };
+
+  template<typename _Tp, typename _Up>
+    struct __is_nothrow_assignable_impl
+    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
+		    __is_nt_assignable_impl<_Tp, _Up>>
+    { };
 
   /// is_nothrow_assignable
   template<typename _Tp, typename _Up>
@@ -2769,23 +2809,13 @@
   template<typename _Tp, typename _Up>
     struct is_swappable_with
     : public __is_swappable_with_impl<_Tp, _Up>::type
-    {
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
-	"first template argument must be a complete class or an unbounded array");
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
-	"second template argument must be a complete class or an unbounded array");
-    };
+    { };
 
   /// is_nothrow_swappable_with
   template<typename _Tp, typename _Up>
     struct is_nothrow_swappable_with
     : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
-    {
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
-	"first template argument must be a complete class or an unbounded array");
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
-	"second template argument must be a complete class or an unbounded array");
-    };
+    { };
 
 #if __cplusplus >= 201402L
   /// is_swappable_with_v
@@ -2920,13 +2950,7 @@
   template<typename _Functor, typename... _ArgTypes>
     struct invoke_result
     : public __invoke_result<_Functor, _ArgTypes...>
-    {
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
-	"_Functor must be a complete class or an unbounded array");
-      static_assert((std::__is_complete_or_unbounded(
-	__type_identity<_ArgTypes>{}) && ...),
-	"each argument type must be a complete class or an unbounded array");
-    };
+    { };
 
   /// std::invoke_result_t
   template<typename _Fn, typename... _Args>
@@ -2939,9 +2963,6 @@
     {
       static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 	"_Fn must be a complete class or an unbounded array");
-      static_assert((std::__is_complete_or_unbounded(
-	__type_identity<_ArgTypes>{}) && ...),
-	"each argument type must be a complete class or an unbounded array");
     };
 
   /// std::is_invocable_r
@@ -2951,11 +2972,6 @@
     {
       static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 	"_Fn must be a complete class or an unbounded array");
-      static_assert((std::__is_complete_or_unbounded(
-	__type_identity<_ArgTypes>{}) && ...),
-	"each argument type must be a complete class or an unbounded array");
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
-	"_Ret must be a complete class or an unbounded array");
     };
 
   /// std::is_nothrow_invocable
@@ -2966,9 +2982,6 @@
     {
       static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 	"_Fn must be a complete class or an unbounded array");
-      static_assert((std::__is_complete_or_unbounded(
-	__type_identity<_ArgTypes>{}) && ...),
-	"each argument type must be a complete class or an unbounded array");
     };
 
   template<typename _Result, typename _Ret, typename = void>
@@ -2986,15 +2999,7 @@
     struct is_nothrow_invocable_r
     : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
              __call_is_nothrow_<_Fn, _ArgTypes...>>::type
-    {
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
-	"_Fn must be a complete class or an unbounded array");
-      static_assert((std::__is_complete_or_unbounded(
-	__type_identity<_ArgTypes>{}) && ...),
-	"each argument type must be a complete class or an unbounded array");
-      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
-	"_Ret must be a complete class or an unbounded array");
-    };
+    { };
 
   /// std::is_invocable_v

