--- a/libstdc++-v3/include/bits/stl_tree.h	2022-01-04 18:38:08.518679289 +0900
+++ b/libstdc++-v3/include/bits/stl_tree.h	2022-01-04 18:39:41.668530850 +0900
@@ -315,11 +315,9 @@
       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       { return __x._M_node == __y._M_node; }
 
-#if ! __cpp_lib_three_way_comparison
       friend bool
       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       { return __x._M_node != __y._M_node; }
-#endif
 
       _Base_ptr _M_node;
   };
@@ -396,11 +394,9 @@
       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       { return __x._M_node == __y._M_node; }
 
-#if ! __cpp_lib_three_way_comparison
       friend bool
       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       { return __x._M_node != __y._M_node; }
-#endif
 
       _Base_ptr _M_node;
     };
@@ -415,6 +411,21 @@
   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
 			       _Rb_tree_node_base& __header) throw ();
 
+#if __cplusplus >= 201402L
+  template<typename _Cmp, typename _SfinaeType, typename = __void_t<>>
+    struct __has_is_transparent
+    { };
+
+  template<typename _Cmp, typename _SfinaeType>
+    struct __has_is_transparent<_Cmp, _SfinaeType,
+				__void_t<typename _Cmp::is_transparent>>
+    { typedef void type; };
+
+  template<typename _Cmp, typename _SfinaeType>
+    using __has_is_transparent_t
+      = typename __has_is_transparent<_Cmp, _SfinaeType>::type;
+#endif
+
 #if __cplusplus > 201402L
   template<typename _Tree1, typename _Cmp2>
     struct _Rb_tree_merge_helper { };
@@ -463,7 +474,11 @@
 
 	template<typename _Arg>
 	  _Link_type
-	  operator()(_GLIBCXX_FWDREF(_Arg) __arg)
+#if __cplusplus < 201103L
+	  operator()(const _Arg& __arg)
+#else
+	  operator()(_Arg&& __arg)
+#endif
 	  {
 	    _Link_type __node = static_cast<_Link_type>(_M_extract());
 	    if (__node)
@@ -525,7 +540,11 @@
 
 	template<typename _Arg>
 	  _Link_type
-	  operator()(_GLIBCXX_FWDREF(_Arg) __arg) const
+#if __cplusplus < 201103L
+	  operator()(const _Arg& __arg) const
+#else
+	  operator()(_Arg&& __arg) const
+#endif
 	  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }
 
       private:
@@ -632,17 +651,11 @@
 	_M_put_node(__p);
       }
 
-      template<bool _MoveValue, typename _NodeGen>
+      template<typename _NodeGen>
 	_Link_type
-	_M_clone_node(_Link_type __x, _NodeGen& __node_gen)
+	_M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 	{
-#if __cplusplus >= 201103L
-	  using _Vp = typename conditional<_MoveValue,
-					   value_type&&,
-					   const value_type&>::type;
-#endif
-	  _Link_type __tmp
-	    = __node_gen(_GLIBCXX_FORWARD(_Vp, *__x->_M_valptr()));
+	  _Link_type __tmp = __node_gen(*__x->_M_valptr());
 	  __tmp->_M_color = __x->_M_color;
 	  __tmp->_M_left = 0;
 	  __tmp->_M_right = 0;
@@ -674,7 +687,6 @@
 	  _Rb_tree_impl(const _Rb_tree_impl& __x)
 	  : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
 	  , _Base_key_compare(__x._M_key_compare)
-	  , _Rb_tree_header()
 	  { }
 
 #if __cplusplus < 201103L
@@ -682,9 +694,12 @@
 	  : _Node_allocator(__a), _Base_key_compare(__comp)
 	  { }
 #else
-	  _Rb_tree_impl(_Rb_tree_impl&&)
-	    noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
-	  = default;
+	  _Rb_tree_impl(_Rb_tree_impl&& __x)
+	  noexcept( is_nothrow_move_constructible<_Base_key_compare>::value )
+	  : _Node_allocator(std::move(__x)),
+	    _Base_key_compare(std::move(__x)),
+	    _Rb_tree_header(std::move(__x))
+	  { }
 
 	  explicit
 	  _Rb_tree_impl(_Node_allocator&& __a)
@@ -731,12 +746,8 @@
       { return this->_M_impl._M_header._M_right; }
 
       _Link_type
-      _M_mbegin() const _GLIBCXX_NOEXCEPT
-      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
-
-      _Link_type
       _M_begin() _GLIBCXX_NOEXCEPT
-      { return _M_mbegin(); }
+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
 
       _Const_Link_type
       _M_begin() const _GLIBCXX_NOEXCEPT
@@ -753,6 +764,10 @@
       _M_end() const _GLIBCXX_NOEXCEPT
       { return &this->_M_impl._M_header; }
 
+      static const_reference
+      _S_value(_Const_Link_type __x)
+      { return *__x->_M_valptr(); }
+
       static const _Key&
       _S_key(_Const_Link_type __x)
       {
@@ -791,6 +806,10 @@
       _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
       { return static_cast<_Const_Link_type>(__x->_M_right); }
 
+      static const_reference
+      _S_value(_Const_Base_ptr __x)
+      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }
+
       static const _Key&
       _S_key(_Const_Base_ptr __x)
       { return _S_key(static_cast<_Const_Link_type>(__x)); }

