--- a/libstdc++-v3/src/c++11/futex.cc	2021-07-28 15:55:09.336315000 +0900
+++ b/libstdc++-v3/src/c++11/futex.cc	2022-01-04 21:19:21.986762440 +0900
@@ -88,7 +88,7 @@
     const auto rel_s = abs_s.count() - now_s;
 
     // Convert the absolute timeout to a relative timeout, without overflow.
-    if (rel_s > __int_traits<syscall_time_t>::__max) [[unlikely]]
+    if (rel_s > __int_traits<syscall_time_t>::__max) 
       {
 	rt.tv_sec = __int_traits<syscall_time_t>::__max;
 	rt.tv_nsec = 999999999;
@@ -132,7 +132,7 @@
 	      return false;
 
 	    syscall_timespec rt;
-	    if (__s.count() > __int_traits<syscall_time_t>::__max) [[unlikely]]
+	    if (__s.count() > __int_traits<syscall_time_t>::__max) 
 	      rt.tv_sec = __int_traits<syscall_time_t>::__max;
 	    else
 	      rt.tv_sec = __s.count();
@@ -204,11 +204,11 @@
 	if (!futex_clock_monotonic_unavailable.load(std::memory_order_relaxed))
 	  {
 	    // futex sets errno=EINVAL for absolute timeouts before the epoch.
-	    if (__s.count() < 0) [[unlikely]]
+	    if (__s.count() < 0) 
 	      return false;
 
 	    syscall_timespec rt;
-	    if (__s.count() > __int_traits<syscall_time_t>::__max) [[unlikely]]
+	    if (__s.count() > __int_traits<syscall_time_t>::__max) 
 	      rt.tv_sec = __int_traits<syscall_time_t>::__max;
 	    else
 	      rt.tv_sec = __s.count();
