--- a/libstdc++-v3/include/std/tuple	2021-07-28 15:55:09.324315000 +0900
+++ b/libstdc++-v3/include/std/tuple	2021-05-14 17:42:11.000000000 +0900
@@ -39,10 +39,6 @@
 #include <array>
 #include <bits/uses_allocator.h>
 #include <bits/invoke.h>
-#if __cplusplus > 201703L
-# include <compare>
-# define __cpp_lib_constexpr_tuple 201811L
-#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -69,63 +65,11 @@
     = typename conditional<__is_final(_Tp), false_type,
 			   __is_empty_non_tuple<_Tp>>::type;
 
-  template<size_t _Idx, typename _Head,
+  template<std::size_t _Idx, typename _Head,
 	   bool = __empty_not_final<_Head>::value>
     struct _Head_base;
 
-#if __has_cpp_attribute(__no_unique_address__)
-  template<size_t _Idx, typename _Head>
-    struct _Head_base<_Idx, _Head, true>
-    {
-      constexpr _Head_base()
-      : _M_head_impl() { }
-
-      constexpr _Head_base(const _Head& __h)
-      : _M_head_impl(__h) { }
-
-      constexpr _Head_base(const _Head_base&) = default;
-      constexpr _Head_base(_Head_base&&) = default;
-
-      template<typename _UHead>
-	constexpr _Head_base(_UHead&& __h)
-	: _M_head_impl(std::forward<_UHead>(__h)) { }
-
-      _GLIBCXX20_CONSTEXPR
-      _Head_base(allocator_arg_t, __uses_alloc0)
-      : _M_head_impl() { }
-
-      template<typename _Alloc>
-	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
-	: _M_head_impl(allocator_arg, *__a._M_a) { }
-
-      template<typename _Alloc>
-	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
-	: _M_head_impl(*__a._M_a) { }
-
-      template<typename _UHead>
-	_GLIBCXX20_CONSTEXPR
-	_Head_base(__uses_alloc0, _UHead&& __uhead)
-	: _M_head_impl(std::forward<_UHead>(__uhead)) { }
-
-      template<typename _Alloc, typename _UHead>
-	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
-	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
-	{ }
-
-      template<typename _Alloc, typename _UHead>
-	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
-	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
-
-      static constexpr _Head&
-      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
-
-      static constexpr const _Head&
-      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
-
-      [[__no_unique_address__]] _Head _M_head_impl;
-    };
-#else
-  template<size_t _Idx, typename _Head>
+  template<std::size_t _Idx, typename _Head>
     struct _Head_base<_Idx, _Head, true>
     : public _Head
     {
@@ -171,9 +115,8 @@
       static constexpr const _Head&
       _M_head(const _Head_base& __b) noexcept { return __b; }
     };
-#endif
 
-  template<size_t _Idx, typename _Head>
+  template<std::size_t _Idx, typename _Head>
     struct _Head_base<_Idx, _Head, false>
     {
       constexpr _Head_base()
@@ -189,7 +132,6 @@
         constexpr _Head_base(_UHead&& __h)
 	: _M_head_impl(std::forward<_UHead>(__h)) { }
 
-      _GLIBCXX20_CONSTEXPR
       _Head_base(allocator_arg_t, __uses_alloc0)
       : _M_head_impl() { }
 
@@ -202,7 +144,6 @@
 	: _M_head_impl(*__a._M_a) { }
 
       template<typename _UHead>
-	_GLIBCXX20_CONSTEXPR
 	_Head_base(__uses_alloc0, _UHead&& __uhead)
 	: _M_head_impl(std::forward<_UHead>(__uhead)) { }
 
@@ -232,7 +173,7 @@
    * point in the hierarchy; we use it to implement a constant-time
    * get() operation.
    */
-  template<size_t _Idx, typename... _Elements>
+  template<std::size_t _Idx, typename... _Elements>
     struct _Tuple_impl;
 
   /**
@@ -240,12 +181,12 @@
    * and derive from a @c Tuple_impl containing the remaining elements
    * (which contains the @c Tail).
    */
-  template<size_t _Idx, typename _Head, typename... _Tail>
+  template<std::size_t _Idx, typename _Head, typename... _Tail>
     struct _Tuple_impl<_Idx, _Head, _Tail...>
     : public _Tuple_impl<_Idx + 1, _Tail...>,
       private _Head_base<_Idx, _Head>
     {
-      template<size_t, typename...> friend struct _Tuple_impl;
+      template<std::size_t, typename...> friend class _Tuple_impl;
 
       typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
       typedef _Head_base<_Idx, _Head> _Base;
@@ -265,136 +206,131 @@
       constexpr _Tuple_impl()
       : _Inherited(), _Base() { }
 
-      explicit constexpr
-      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
-      : _Inherited(__tail...), _Base(__head)
-      { }
-
-      template<typename _UHead, typename... _UTail,
-	       typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
-	explicit constexpr
-	_Tuple_impl(_UHead&& __head, _UTail&&... __tail)
+      explicit
+      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
+      : _Inherited(__tail...), _Base(__head) { }
+
+      template<typename _UHead, typename... _UTail, typename = typename
+               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
+        explicit
+        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 	: _Inherited(std::forward<_UTail>(__tail)...),
-	  _Base(std::forward<_UHead>(__head))
-	{ }
+	  _Base(std::forward<_UHead>(__head)) { }
 
       constexpr _Tuple_impl(const _Tuple_impl&) = default;
 
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 2729. Missing SFINAE on std::pair::operator=
-      _Tuple_impl& operator=(const _Tuple_impl&) = delete;
-
       constexpr
       _Tuple_impl(_Tuple_impl&& __in)
       noexcept(__and_<is_nothrow_move_constructible<_Head>,
-		      is_nothrow_move_constructible<_Inherited>>::value)
+	              is_nothrow_move_constructible<_Inherited>>::value)
       : _Inherited(std::move(_M_tail(__in))),
-	_Base(std::forward<_Head>(_M_head(__in)))
-      { }
+	_Base(std::forward<_Head>(_M_head(__in))) { }
 
       template<typename... _UElements>
-	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
+        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
-	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
-	{ }
+	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
 
       template<typename _UHead, typename... _UTails>
-	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 	: _Inherited(std::move
 		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
 	  _Base(std::forward<_UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
-	{ }
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 	: _Inherited(__tag, __a),
-	  _Base(__tag, __use_alloc<_Head>(__a))
-	{ }
+          _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 		    const _Head& __head, const _Tail&... __tail)
 	: _Inherited(__tag, __a, __tail...),
-	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
-	{ }
+          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
 
       template<typename _Alloc, typename _UHead, typename... _UTail,
-	       typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
-	_GLIBCXX20_CONSTEXPR
+               typename = typename enable_if<sizeof...(_Tail)
+					     == sizeof...(_UTail)>::type>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _UHead&& __head, _UTail&&... __tail)
+	            _UHead&& __head, _UTail&&... __tail)
 	: _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
-	  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
-		std::forward<_UHead>(__head))
-	{ }
+          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
+	        std::forward<_UHead>(__head)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
-	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl& __in)
+        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
+	            const _Tuple_impl& __in)
 	: _Inherited(__tag, __a, _M_tail(__in)),
-	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
-	{ }
+          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl&& __in)
+	            _Tuple_impl&& __in)
 	: _Inherited(__tag, __a, std::move(_M_tail(__in))),
 	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
-		std::forward<_Head>(_M_head(__in)))
-	{ }
+	        std::forward<_Head>(_M_head(__in))) { }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 		    const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 	: _Inherited(__tag, __a,
 		     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
 	  _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
-	{ }
+		_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) { }
 
       template<typename _Alloc, typename _UHead, typename... _UTails>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+	            _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 	: _Inherited(__tag, __a, std::move
 		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
 	  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
-		std::forward<_UHead>
-		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
-	{ }
+                std::forward<_UHead>
+		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
+
+      _Tuple_impl&
+      operator=(const _Tuple_impl& __in)
+      {
+	_M_head(*this) = _M_head(__in);
+	_M_tail(*this) = _M_tail(__in);
+	return *this;
+      }
+
+      _Tuple_impl&
+      operator=(_Tuple_impl&& __in)
+      noexcept(__and_<is_nothrow_move_assignable<_Head>,
+	              is_nothrow_move_assignable<_Inherited>>::value)
+      {
+	_M_head(*this) = std::forward<_Head>(_M_head(__in));
+	_M_tail(*this) = std::move(_M_tail(__in));
+	return *this;
+      }
 
       template<typename... _UElements>
-	_GLIBCXX20_CONSTEXPR
-	void
-	_M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
-	{
+        _Tuple_impl&
+        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
+        {
 	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
-	  _M_tail(*this)._M_assign(
-	      _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
+	  _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
+	  return *this;
 	}
 
       template<typename _UHead, typename... _UTails>
-	_GLIBCXX20_CONSTEXPR
-	void
-	_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
-	{
+        _Tuple_impl&
+        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
+        {
 	  _M_head(*this) = std::forward<_UHead>
 	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
-	  _M_tail(*this)._M_assign(
-	      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
+	  _M_tail(*this) = std::move
+	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
+	  return *this;
 	}
 
     protected:
-      _GLIBCXX20_CONSTEXPR
       void
       _M_swap(_Tuple_impl& __in)
+      noexcept(__is_nothrow_swappable<_Head>::value
+               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
       {
 	using std::swap;
 	swap(_M_head(*this), _M_head(__in));
@@ -403,11 +339,11 @@
     };
 
   // Basis case of inheritance recursion.
-  template<size_t _Idx, typename _Head>
+  template<std::size_t _Idx, typename _Head>
     struct _Tuple_impl<_Idx, _Head>
     : private _Head_base<_Idx, _Head>
     {
-      template<size_t, typename...> friend struct _Tuple_impl;
+      template<std::size_t, typename...> friend class _Tuple_impl;
 
       typedef _Head_base<_Idx, _Head> _Base;
 
@@ -417,117 +353,109 @@
       static constexpr const _Head&
       _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 
-      constexpr
-      _Tuple_impl()
+      constexpr _Tuple_impl()
       : _Base() { }
 
-      explicit constexpr
-      _Tuple_impl(const _Head& __head)
-      : _Base(__head)
-      { }
+      explicit
+      constexpr _Tuple_impl(const _Head& __head)
+      : _Base(__head) { }
 
       template<typename _UHead>
-	explicit constexpr
-	_Tuple_impl(_UHead&& __head)
-	: _Base(std::forward<_UHead>(__head))
-	{ }
+        explicit
+        constexpr _Tuple_impl(_UHead&& __head)
+	: _Base(std::forward<_UHead>(__head)) { }
 
       constexpr _Tuple_impl(const _Tuple_impl&) = default;
 
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 2729. Missing SFINAE on std::pair::operator=
-      _Tuple_impl& operator=(const _Tuple_impl&) = delete;
-
       constexpr
       _Tuple_impl(_Tuple_impl&& __in)
       noexcept(is_nothrow_move_constructible<_Head>::value)
-      : _Base(std::forward<_Head>(_M_head(__in)))
-      { }
+      : _Base(std::forward<_Head>(_M_head(__in))) { }
 
       template<typename _UHead>
-	constexpr
-	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
-	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
-	{ }
+        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
+	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
 
       template<typename _UHead>
-	constexpr
-	_Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
+        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 	: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 	{ }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
-	: _Base(__tag, __use_alloc<_Head>(__a))
-	{ }
+	: _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
 		    const _Head& __head)
-	: _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), __head)
-	{ }
+	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
 
       template<typename _Alloc, typename _UHead>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _UHead&& __head)
+	            _UHead&& __head)
 	: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
-		std::forward<_UHead>(__head))
-	{ }
+	        std::forward<_UHead>(__head)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
-	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl& __in)
-	: _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
-	{ }
+        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
+	            const _Tuple_impl& __in)
+	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl&& __in)
+	            _Tuple_impl&& __in)
 	: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
-		std::forward<_Head>(_M_head(__in)))
-	{ }
+	        std::forward<_Head>(_M_head(__in))) { }
 
       template<typename _Alloc, typename _UHead>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    const _Tuple_impl<_Idx, _UHead>& __in)
+	            const _Tuple_impl<_Idx, _UHead>& __in)
 	: _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
-		_Tuple_impl<_Idx, _UHead>::_M_head(__in))
-	{ }
+		_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }
 
       template<typename _Alloc, typename _UHead>
-	_GLIBCXX20_CONSTEXPR
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
-		    _Tuple_impl<_Idx, _UHead>&& __in)
+	            _Tuple_impl<_Idx, _UHead>&& __in)
 	: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
-		std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
+                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 	{ }
 
+      _Tuple_impl&
+      operator=(const _Tuple_impl& __in)
+      {
+	_M_head(*this) = _M_head(__in);
+	return *this;
+      }
+
+      _Tuple_impl&
+      operator=(_Tuple_impl&& __in)
+      noexcept(is_nothrow_move_assignable<_Head>::value)
+      {
+	_M_head(*this) = std::forward<_Head>(_M_head(__in));
+	return *this;
+      }
+
       template<typename _UHead>
-	_GLIBCXX20_CONSTEXPR
-	void
-	_M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
-	{
+        _Tuple_impl&
+        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
+        {
 	  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
+	  return *this;
 	}
 
       template<typename _UHead>
-	_GLIBCXX20_CONSTEXPR
-	void
-	_M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
-	{
+        _Tuple_impl&
+        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
+        {
 	  _M_head(*this)
 	    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
+	  return *this;
 	}
 
     protected:
-      _GLIBCXX20_CONSTEXPR
       void
       _M_swap(_Tuple_impl& __in)
+      noexcept(__is_nothrow_swappable<_Head>::value)
       {
 	using std::swap;
 	swap(_M_head(*this), _M_head(__in));
@@ -536,400 +464,411 @@
 
   // Concept utility functions, reused in conditionally-explicit
   // constructors.
-  template<bool, typename... _Types>
-    struct _TupleConstraints
+  template<bool, typename... _Elements>
+  struct _TC
+  {
+    template<typename... _UElements>
+    static constexpr bool _ConstructibleTuple()
     {
-      template<typename _Tp, typename _Up> // Workaround for PR 96592
-	using is_constructible
-	  = __bool_constant<__is_constructible(_Tp, _Up)>;
-
-      // Constraint for a non-explicit constructor.
-      // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
-      // and every Ui is implicitly convertible to Ti.
-      template<typename... _UTypes>
-	static constexpr bool __is_implicitly_constructible()
-	{
-	  return __and_<is_constructible<_Types, _UTypes>...,
-			is_convertible<_UTypes, _Types>...
-			>::value;
-	}
+      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
+    }
 
-      // Constraint for a non-explicit constructor.
-      // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
-      // but not every Ui is implicitly convertible to Ti.
-      template<typename... _UTypes>
-	static constexpr bool __is_explicitly_constructible()
-	{
-	  return __and_<is_constructible<_Types, _UTypes>...,
-			__not_<__and_<is_convertible<_UTypes, _Types>...>>
-			>::value;
-	}
+    template<typename... _UElements>
+    static constexpr bool _ImplicitlyConvertibleTuple()
+    {
+      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
+    }
 
-      static constexpr bool __is_implicitly_default_constructible()
-      {
-	return __and_<std::__is_implicitly_default_constructible<_Types>...
-		      >::value;
-      }
+    template<typename... _UElements>
+    static constexpr bool _MoveConstructibleTuple()
+    {
+      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
+    }
 
-      static constexpr bool __is_explicitly_default_constructible()
-      {
-	return __and_<is_default_constructible<_Types>...,
-		      __not_<__and_<
-			std::__is_implicitly_default_constructible<_Types>...>
-		      >>::value;
-      }
-    };
+    template<typename... _UElements>
+    static constexpr bool _ImplicitlyMoveConvertibleTuple()
+    {
+      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
+    }
 
-  // Partial specialization used when a required precondition isn't met,
-  // e.g. when sizeof...(_Types) != sizeof...(_UTypes).
-  template<typename... _Types>
-    struct _TupleConstraints<false, _Types...>
-    {
-      template<typename... _UTypes>
-	static constexpr bool __is_implicitly_constructible()
-	{ return false; }
-
-      template<typename... _UTypes>
-	static constexpr bool __is_explicitly_constructible()
-	{ return false; }
-    };
+    template<typename _SrcTuple>
+    static constexpr bool _NonNestedTuple()
+    {
+      return  __and_<__not_<is_same<tuple<_Elements...>,
+                                   typename remove_cv<
+                                     typename remove_reference<_SrcTuple>::type
+                                   >::type>>,
+                     __not_<is_convertible<_SrcTuple, _Elements...>>,
+                     __not_<is_constructible<_Elements..., _SrcTuple>>
+              >::value;
+    }
+    template<typename... _UElements>
+    static constexpr bool _NotSameTuple()
+    {
+      return  __not_<is_same<tuple<_Elements...>,
+			     typename remove_const<
+			       typename remove_reference<_UElements...>::type
+			       >::type>>::value;
+    }
+  };
 
-  /// Primary class template, tuple
   template<typename... _Elements>
-    class tuple : public _Tuple_impl<0, _Elements...>
+  struct _TC<false, _Elements...>
+  {
+    template<typename... _UElements>
+    static constexpr bool _ConstructibleTuple()
     {
-      typedef _Tuple_impl<0, _Elements...> _Inherited;
-
-      template<bool _Cond>
-	using _TCC = _TupleConstraints<_Cond, _Elements...>;
+      return false;
+    }
 
-      // Constraint for non-explicit default constructor
-      template<bool _Dummy>
-	using _ImplicitDefaultCtor = __enable_if_t<
-	  _TCC<_Dummy>::__is_implicitly_default_constructible(),
-	  bool>;
-
-      // Constraint for explicit default constructor
-      template<bool _Dummy>
-	using _ExplicitDefaultCtor = __enable_if_t<
-	  _TCC<_Dummy>::__is_explicitly_default_constructible(),
-	  bool>;
-
-      // Constraint for non-explicit constructors
-      template<bool _Cond, typename... _Args>
-	using _ImplicitCtor = __enable_if_t<
-	  _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
-	  bool>;
-
-      // Constraint for non-explicit constructors
-      template<bool _Cond, typename... _Args>
-	using _ExplicitCtor = __enable_if_t<
-	  _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
-	  bool>;
+    template<typename... _UElements>
+    static constexpr bool _ImplicitlyConvertibleTuple()
+    {
+      return false;
+    }
 
-      template<typename... _UElements>
-	static constexpr
-	__enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
-	__assignable()
-	{ return __and_<is_assignable<_Elements&, _UElements>...>::value; }
+    template<typename... _UElements>
+    static constexpr bool _MoveConstructibleTuple()
+    {
+      return false;
+    }
 
-      // Condition for noexcept-specifier of an assignment operator.
-      template<typename... _UElements>
-	static constexpr bool __nothrow_assignable()
-	{
-	  return
-	    __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
-	}
+    template<typename... _UElements>
+    static constexpr bool _ImplicitlyMoveConvertibleTuple()
+    {
+      return false;
+    }
 
-      // Condition for noexcept-specifier of a constructor.
-      template<typename... _UElements>
-	static constexpr bool __nothrow_constructible()
-	{
-	  return
-	    __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
-	}
+    template<typename... _UElements>
+    static constexpr bool _NonNestedTuple()
+    {
+      return true;
+    }
+    template<typename... _UElements>
+    static constexpr bool _NotSameTuple()
+    {
+      return  true;
+    }
+  };
 
-      // Constraint for tuple(_UTypes&&...) where sizeof...(_UTypes) == 1.
-      template<typename _Up>
-	static constexpr bool __valid_args()
-	{
-	  return sizeof...(_Elements) == 1
-	    && !is_same<tuple, __remove_cvref_t<_Up>>::value;
-	}
+  /// Primary class template, tuple
+  template<typename... _Elements>
+    class tuple : public _Tuple_impl<0, _Elements...>
+    {
+      typedef _Tuple_impl<0, _Elements...> _Inherited;
 
-      // Constraint for tuple(_UTypes&&...) where sizeof...(_UTypes) > 1.
-      template<typename, typename, typename... _Tail>
-	static constexpr bool __valid_args()
-	{ return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
-
-      /* Constraint for constructors with a tuple<UTypes...> parameter ensures
-       * that the constructor is only viable when it would not interfere with
-       * tuple(UTypes&&...) or tuple(const tuple&) or tuple(tuple&&).
-       * Such constructors are only viable if:
-       * either sizeof...(Types) != 1,
-       * or (when Types... expands to T and UTypes... expands to U)
-       * is_convertible_v<TUPLE, T>, is_constructible_v<T, TUPLE>,
-       * and is_same_v<T, U> are all false.
-       */
-      template<typename _Tuple, typename = tuple,
-	       typename = __remove_cvref_t<_Tuple>>
-	struct _UseOtherCtor
-	: false_type
-	{ };
-      // If TUPLE is convertible to the single element in *this,
-      // then TUPLE should match tuple(UTypes&&...) instead.
-      template<typename _Tuple, typename _Tp, typename _Up>
-	struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
-	: __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
-	{ };
-      // If TUPLE and *this each have a single element of the same type,
-      // then TUPLE should match a copy/move constructor instead.
-      template<typename _Tuple, typename _Tp>
-	struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
-	: true_type
-	{ };
-
-      // Return true iff sizeof...(Types) == 1 && tuple_size_v<TUPLE> == 1
-      // and the single element in Types can be initialized from TUPLE,
-      // or is the same type as tuple_element_t<0, TUPLE>.
-      template<typename _Tuple>
-	static constexpr bool __use_other_ctor()
-	{ return _UseOtherCtor<_Tuple>::value; }
+      // Used for constraining the default constructor so
+      // that it becomes dependent on the constraints.
+      template<typename _Dummy>
+      struct _TC2
+      {
+        static constexpr bool _DefaultConstructibleTuple()
+        {
+          return __and_<is_default_constructible<_Elements>...>::value;
+        }
+        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
+        {
+          return __and_<__is_implicitly_default_constructible<_Elements>...>
+            ::value;
+        }
+      };
 
     public:
       template<typename _Dummy = void,
-	       _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
-	constexpr
-	tuple()
-	noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
-	: _Inherited() { }
+               typename enable_if<_TC2<_Dummy>::
+                                    _ImplicitlyDefaultConstructibleTuple(),
+                                  bool>::type = true>
+      constexpr tuple()
+      : _Inherited() { }
 
       template<typename _Dummy = void,
-	       _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
-	explicit constexpr
-	tuple()
-	noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
-	: _Inherited() { }
-
-      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
-	       _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
-	constexpr
-	tuple(const _Elements&... __elements)
-	noexcept(__nothrow_constructible<const _Elements&...>())
-	: _Inherited(__elements...) { }
-
-      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
-	       _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
-	explicit constexpr
-	tuple(const _Elements&... __elements)
-	noexcept(__nothrow_constructible<const _Elements&...>())
-	: _Inherited(__elements...) { }
-
-      template<typename... _UElements,
-	       bool _Valid = __valid_args<_UElements...>(),
-	       _ImplicitCtor<_Valid, _UElements...> = true>
-	constexpr
-	tuple(_UElements&&... __elements)
-	noexcept(__nothrow_constructible<_UElements...>())
-	: _Inherited(std::forward<_UElements>(__elements)...) { }
-
-      template<typename... _UElements,
-	       bool _Valid = __valid_args<_UElements...>(),
-	       _ExplicitCtor<_Valid, _UElements...> = false>
-	explicit constexpr
-	tuple(_UElements&&... __elements)
-	noexcept(__nothrow_constructible<_UElements...>())
+               typename enable_if<_TC2<_Dummy>::
+                                    _DefaultConstructibleTuple()
+                                  &&
+                                  !_TC2<_Dummy>::
+                                    _ImplicitlyDefaultConstructibleTuple(),
+                                  bool>::type = false>
+      explicit constexpr tuple()
+      : _Inherited() { }
+
+      // Shortcut for the cases where constructors taking _Elements...
+      // need to be constrained.
+      template<typename _Dummy> using _TCC =
+        _TC<is_same<_Dummy, void>::value,
+            _Elements...>;
+
+      template<typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_Elements...>()
+                 && _TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_Elements...>()
+                 && (sizeof...(_Elements) >= 1),
+               bool>::type=true>
+        constexpr tuple(const _Elements&... __elements)
+      : _Inherited(__elements...) { }
+
+      template<typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_Elements...>()
+                 && !_TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_Elements...>()
+                 && (sizeof...(_Elements) >= 1),
+               bool>::type=false>
+      explicit constexpr tuple(const _Elements&... __elements)
+      : _Inherited(__elements...) { }
+
+      // Shortcut for the cases where constructors taking _UElements...
+      // need to be constrained.
+      template<typename... _UElements> using _TMC =
+                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
+		      && (_TC<(sizeof...(_UElements)==1), _Elements...>::
+			  template _NotSameTuple<_UElements...>()),
+                      _Elements...>;
+
+      // Shortcut for the cases where constructors taking tuple<_UElements...>
+      // need to be constrained.
+      template<typename... _UElements> using _TMCT =
+                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
+		      && !is_same<tuple<_Elements...>,
+				  tuple<_UElements...>>::value,
+                      _Elements...>;
+
+      template<typename... _UElements, typename
+	       enable_if<
+		  _TMC<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && _TMC<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && (sizeof...(_Elements) >= 1),
+        bool>::type=true>
+        constexpr tuple(_UElements&&... __elements)
+        : _Inherited(std::forward<_UElements>(__elements)...) { }
+
+      template<typename... _UElements, typename
+        enable_if<
+		  _TMC<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && !_TMC<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && (sizeof...(_Elements) >= 1),
+        bool>::type=false>
+        explicit constexpr tuple(_UElements&&... __elements)
 	: _Inherited(std::forward<_UElements>(__elements)...) {	}
 
       constexpr tuple(const tuple&) = default;
 
       constexpr tuple(tuple&&) = default;
 
-      template<typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			   && !__use_other_ctor<const tuple<_UElements...>&>(),
-	       _ImplicitCtor<_Valid, const _UElements&...> = true>
-	constexpr
-	tuple(const tuple<_UElements...>& __in)
-	noexcept(__nothrow_constructible<const _UElements&...>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
-	{ }
-
-      template<typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			   && !__use_other_ctor<const tuple<_UElements...>&>(),
-	       _ExplicitCtor<_Valid, const _UElements&...> = false>
-	explicit constexpr
-	tuple(const tuple<_UElements...>& __in)
-	noexcept(__nothrow_constructible<const _UElements&...>())
-	: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
-	{ }
-
-      template<typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<tuple<_UElements...>&&>(),
-	       _ImplicitCtor<_Valid, _UElements...> = true>
-	constexpr
-	tuple(tuple<_UElements...>&& __in)
-	noexcept(__nothrow_constructible<_UElements...>())
-	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
-
-      template<typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<tuple<_UElements...>&&>(),
-	       _ExplicitCtor<_Valid, _UElements...> = false>
-	explicit constexpr
-	tuple(tuple<_UElements...>&& __in)
-	noexcept(__nothrow_constructible<_UElements...>())
-	: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
+      // Shortcut for the cases where constructors taking tuples
+      // must avoid creating temporaries.
+      template<typename _Dummy> using _TNTC =
+        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
+            _Elements...>;
+
+      template<typename... _UElements, typename _Dummy = void, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _ConstructibleTuple<_UElements...>()
+                  && _TMCT<_UElements...>::template
+                    _ImplicitlyConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<const tuple<_UElements...>&>(),
+        bool>::type=true>
+        constexpr tuple(const tuple<_UElements...>& __in)
+        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+        { }
+
+      template<typename... _UElements, typename _Dummy = void, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _ConstructibleTuple<_UElements...>()
+                  && !_TMCT<_UElements...>::template
+                    _ImplicitlyConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<const tuple<_UElements...>&>(),
+        bool>::type=false>
+        explicit constexpr tuple(const tuple<_UElements...>& __in)
+        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
+        { }
+
+      template<typename... _UElements, typename _Dummy = void, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && _TMCT<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=true>
+        constexpr tuple(tuple<_UElements...>&& __in)
+        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
+
+      template<typename... _UElements, typename _Dummy = void, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && !_TMCT<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=false>
+        explicit constexpr tuple(tuple<_UElements...>&& __in)
+        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
 
       // Allocator-extended constructors.
 
-      template<typename _Alloc,
-	       _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc>
 	tuple(allocator_arg_t __tag, const _Alloc& __a)
 	: _Inherited(__tag, __a) { }
 
-      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
-	       _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_Elements...>()
+                 && _TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_Elements...>(),
+               bool>::type=true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const _Elements&... __elements)
 	: _Inherited(__tag, __a, __elements...) { }
 
-      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
-	       _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
-	_GLIBCXX20_CONSTEXPR
-	explicit
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      const _Elements&... __elements)
+      template<typename _Alloc, typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_Elements...>()
+                 && !_TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_Elements...>(),
+               bool>::type=false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
+                       const _Elements&... __elements)
 	: _Inherited(__tag, __a, __elements...) { }
 
-      template<typename _Alloc, typename... _UElements,
-	       bool _Valid = __valid_args<_UElements...>(),
-	       _ImplicitCtor<_Valid, _UElements...> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename... _UElements, typename
+        enable_if<_TMC<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && _TMC<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
+        bool>::type=true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      _UElements&&... __elements)
 	: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
-	{ }
+       	{ }
 
-      template<typename _Alloc, typename... _UElements,
-		 bool _Valid = __valid_args<_UElements...>(),
-	       _ExplicitCtor<_Valid, _UElements...> = false>
-	_GLIBCXX20_CONSTEXPR
-	explicit
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename... _UElements, typename
+        enable_if<_TMC<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && !_TMC<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
+        bool>::type=false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      _UElements&&... __elements)
 	: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
-	{ }
+        { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
 
-      template<typename _Alloc, typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<const tuple<_UElements...>&>(),
-	       _ImplicitCtor<_Valid, const _UElements&...> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _Dummy = void,
+	       typename... _UElements, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _ConstructibleTuple<_UElements...>()
+                  && _TMCT<_UElements...>::template
+                    _ImplicitlyConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const tuple<_UElements...>& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 	{ }
 
-      template<typename _Alloc, typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<const tuple<_UElements...>&>(),
-	       _ExplicitCtor<_Valid, const _UElements&...> = false>
-	_GLIBCXX20_CONSTEXPR
-	explicit
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _Dummy = void,
+	       typename... _UElements, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _ConstructibleTuple<_UElements...>()
+                  && !_TMCT<_UElements...>::template
+                    _ImplicitlyConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const tuple<_UElements...>& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 	{ }
 
-      template<typename _Alloc, typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<tuple<_UElements...>&&>(),
-	       _ImplicitCtor<_Valid, _UElements...> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _Dummy = void,
+	       typename... _UElements, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && _TMCT<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      tuple<_UElements...>&& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 	{ }
 
-      template<typename _Alloc, typename... _UElements,
-	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
-			     && !__use_other_ctor<tuple<_UElements...>&&>(),
-	       _ExplicitCtor<_Valid, _UElements...> = false>
-	_GLIBCXX20_CONSTEXPR
-	explicit
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _Dummy = void,
+	       typename... _UElements, typename
+        enable_if<_TMCT<_UElements...>::template
+                    _MoveConstructibleTuple<_UElements...>()
+                  && !_TMCT<_UElements...>::template
+                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
+                  && _TNTC<_Dummy>::template
+                    _NonNestedTuple<tuple<_UElements...>&&>(),
+        bool>::type=false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      tuple<_UElements...>&& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 	{ }
 
-      // tuple assignment
-
-      _GLIBCXX20_CONSTEXPR
       tuple&
-      operator=(typename conditional<__assignable<const _Elements&...>(),
-				     const tuple&,
-				     const __nonesuch&>::type __in)
-      noexcept(__nothrow_assignable<const _Elements&...>())
+      operator=(const tuple& __in)
       {
-	this->_M_assign(__in);
+	static_cast<_Inherited&>(*this) = __in;
 	return *this;
       }
 
-      _GLIBCXX20_CONSTEXPR
       tuple&
-      operator=(typename conditional<__assignable<_Elements...>(),
-				     tuple&&,
-				     __nonesuch&&>::type __in)
-      noexcept(__nothrow_assignable<_Elements...>())
+      operator=(tuple&& __in)
+      noexcept(is_nothrow_move_assignable<_Inherited>::value)
       {
-	this->_M_assign(std::move(__in));
+	static_cast<_Inherited&>(*this) = std::move(__in);
 	return *this;
       }
 
       template<typename... _UElements>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<const _UElements&...>(), tuple&>
-	operator=(const tuple<_UElements...>& __in)
-	noexcept(__nothrow_assignable<const _UElements&...>())
-	{
-	  this->_M_assign(__in);
+	typename
+	       enable_if<sizeof...(_UElements)
+			 == sizeof...(_Elements), tuple&>::type
+        operator=(const tuple<_UElements...>& __in)
+        {
+	  static_cast<_Inherited&>(*this) = __in;
 	  return *this;
 	}
 
       template<typename... _UElements>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<_UElements...>(), tuple&>
-	operator=(tuple<_UElements...>&& __in)
-	noexcept(__nothrow_assignable<_UElements...>())
-	{
-	  this->_M_assign(std::move(__in));
+	typename
+	       enable_if<sizeof...(_UElements)
+			 == sizeof...(_Elements), tuple&>::type
+        operator=(tuple<_UElements...>&& __in)
+        {
+	  static_cast<_Inherited&>(*this) = std::move(__in);
 	  return *this;
 	}
 
-      // tuple swap
-      _GLIBCXX20_CONSTEXPR
       void
       swap(tuple& __in)
-      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
+      noexcept(noexcept(__in._M_swap(__in)))
       { _Inherited::_M_swap(__in); }
     };
 
@@ -957,11 +896,9 @@
       tuple() = default;
       // No-op allocator constructors.
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t, const _Alloc&) noexcept { }
+	tuple(allocator_arg_t, const _Alloc&) { }
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
+	tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
     };
 
   /// Partial specialization, 2-element tuple.
@@ -971,355 +908,355 @@
     {
       typedef _Tuple_impl<0, _T1, _T2> _Inherited;
 
-      // Constraint for non-explicit default constructor
-      template<bool _Dummy, typename _U1, typename _U2>
-	using _ImplicitDefaultCtor = __enable_if_t<
-	  _TupleConstraints<_Dummy, _U1, _U2>::
-	    __is_implicitly_default_constructible(),
-	  bool>;
-
-      // Constraint for explicit default constructor
-      template<bool _Dummy, typename _U1, typename _U2>
-	using _ExplicitDefaultCtor = __enable_if_t<
-	  _TupleConstraints<_Dummy, _U1, _U2>::
-	    __is_explicitly_default_constructible(),
-	  bool>;
-
-      template<bool _Dummy>
-	using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;
-
-      // Constraint for non-explicit constructors
-      template<bool _Cond, typename _U1, typename _U2>
-	using _ImplicitCtor = __enable_if_t<
-	  _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
-	  bool>;
-
-      // Constraint for non-explicit constructors
-      template<bool _Cond, typename _U1, typename _U2>
-	using _ExplicitCtor = __enable_if_t<
-	  _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
-	  bool>;
-
-      template<typename _U1, typename _U2>
-	static constexpr bool __assignable()
-	{
-	  return __and_<is_assignable<_T1&, _U1>,
-			is_assignable<_T2&, _U2>>::value;
-	}
-
-      template<typename _U1, typename _U2>
-	static constexpr bool __nothrow_assignable()
-	{
-	  return __and_<is_nothrow_assignable<_T1&, _U1>,
-			is_nothrow_assignable<_T2&, _U2>>::value;
-	}
-
-      template<typename _U1, typename _U2>
-	static constexpr bool __nothrow_constructible()
-	{
-	  return __and_<is_nothrow_constructible<_T1, _U1>,
-			    is_nothrow_constructible<_T2, _U2>>::value;
-	}
-
-      static constexpr bool __nothrow_default_constructible()
-      {
-	return __and_<is_nothrow_default_constructible<_T1>,
-		      is_nothrow_default_constructible<_T2>>::value;
-      }
-
-      template<typename _U1>
-	static constexpr bool __is_alloc_arg()
-	{ return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }
-
     public:
-      template<bool _Dummy = true,
-	       _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
-	constexpr
-	tuple()
-	noexcept(__nothrow_default_constructible())
-	: _Inherited() { }
-
-      template<bool _Dummy = true,
-	       _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
-	explicit constexpr
-	tuple()
-	noexcept(__nothrow_default_constructible())
-	: _Inherited() { }
-
-      template<bool _Dummy = true,
-	       _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
-	constexpr
-	tuple(const _T1& __a1, const _T2& __a2)
-	noexcept(__nothrow_constructible<const _T1&, const _T2&>())
-	: _Inherited(__a1, __a2) { }
-
-      template<bool _Dummy = true,
-	       _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
-	explicit constexpr
-	tuple(const _T1& __a1, const _T2& __a2)
-	noexcept(__nothrow_constructible<const _T1&, const _T2&>())
-	: _Inherited(__a1, __a2) { }
-
-      template<typename _U1, typename _U2,
-	       _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
-	constexpr
-	tuple(_U1&& __a1, _U2&& __a2)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template <typename _U1 = _T1,
+                typename _U2 = _T2,
+                typename enable_if<__and_<
+                                     __is_implicitly_default_constructible<_U1>,
+                                     __is_implicitly_default_constructible<_U2>>
+                                   ::value, bool>::type = true>
+
+      constexpr tuple()
+      : _Inherited() { }
+
+      template <typename _U1 = _T1,
+                typename _U2 = _T2,
+                typename enable_if<
+                  __and_<
+                    is_default_constructible<_U1>,
+                    is_default_constructible<_U2>,
+                    __not_<
+                      __and_<__is_implicitly_default_constructible<_U1>,
+                             __is_implicitly_default_constructible<_U2>>>>
+                  ::value, bool>::type = false>
+
+      explicit constexpr tuple()
+      : _Inherited() { }
+
+      // Shortcut for the cases where constructors taking _T1, _T2
+      // need to be constrained.
+      template<typename _Dummy> using _TCC =
+        _TC<is_same<_Dummy, void>::value, _T1, _T2>;
+
+      template<typename _Dummy = void, typename
+               enable_if<_TCC<_Dummy>::template
+                           _ConstructibleTuple<_T1, _T2>()
+                         && _TCC<_Dummy>::template
+                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
+	bool>::type = true>
+        constexpr tuple(const _T1& __a1, const _T2& __a2)
+        : _Inherited(__a1, __a2) { }
+
+      template<typename _Dummy = void, typename
+               enable_if<_TCC<_Dummy>::template
+                           _ConstructibleTuple<_T1, _T2>()
+                         && !_TCC<_Dummy>::template
+                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
+	bool>::type = false>
+        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
+        : _Inherited(__a1, __a2) { }
+
+      // Shortcut for the cases where constructors taking _U1, _U2
+      // need to be constrained.
+      using _TMC = _TC<true, _T1, _T2>;
+
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
+	          && !is_same<typename decay<_U1>::type,
+			      allocator_arg_t>::value,
+	bool>::type = true>
+        constexpr tuple(_U1&& __a1, _U2&& __a2)
 	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
 
-      template<typename _U1, typename _U2,
-	       _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
-	explicit constexpr
-	tuple(_U1&& __a1, _U2&& __a2)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
+	          && !is_same<typename decay<_U1>::type,
+			      allocator_arg_t>::value,
+	bool>::type = false>
+        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
 
       constexpr tuple(const tuple&) = default;
 
       constexpr tuple(tuple&&) = default;
 
-      template<typename _U1, typename _U2,
-	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
-	constexpr
-	tuple(const tuple<_U1, _U2>& __in)
-	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        constexpr tuple(const tuple<_U1, _U2>& __in)
 	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }
 
-      template<typename _U1, typename _U2,
-	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
-	explicit constexpr
-	tuple(const tuple<_U1, _U2>& __in)
-	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }
 
-      template<typename _U1, typename _U2,
-	       _ImplicitCtor<true, _U1, _U2> = true>
-	constexpr
-	tuple(tuple<_U1, _U2>&& __in)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        constexpr tuple(tuple<_U1, _U2>&& __in)
 	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }
 
-      template<typename _U1, typename _U2,
-	       _ExplicitCtor<true, _U1, _U2> = false>
-	explicit constexpr
-	tuple(tuple<_U1, _U2>&& __in)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }
 
-      template<typename _U1, typename _U2,
-	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
-	constexpr
-	tuple(const pair<_U1, _U2>& __in)
-	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        constexpr tuple(const pair<_U1, _U2>& __in)
 	: _Inherited(__in.first, __in.second) { }
 
-      template<typename _U1, typename _U2,
-	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
-	explicit constexpr
-	tuple(const pair<_U1, _U2>& __in)
-	noexcept(__nothrow_constructible<const _U1&, const _U2&>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 	: _Inherited(__in.first, __in.second) { }
 
-      template<typename _U1, typename _U2,
-	       _ImplicitCtor<true, _U1, _U2> = true>
-	constexpr
-	tuple(pair<_U1, _U2>&& __in)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        constexpr tuple(pair<_U1, _U2>&& __in)
 	: _Inherited(std::forward<_U1>(__in.first),
 		     std::forward<_U2>(__in.second)) { }
 
-      template<typename _U1, typename _U2,
-	       _ExplicitCtor<true, _U1, _U2> = false>
-	explicit constexpr
-	tuple(pair<_U1, _U2>&& __in)
-	noexcept(__nothrow_constructible<_U1, _U2>())
+      template<typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 	: _Inherited(std::forward<_U1>(__in.first),
 		     std::forward<_U2>(__in.second)) { }
 
       // Allocator-extended constructors.
 
-      template<typename _Alloc,
-	       _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc>
 	tuple(allocator_arg_t __tag, const _Alloc& __a)
 	: _Inherited(__tag, __a) { }
 
-      template<typename _Alloc, bool _Dummy = true,
-	       _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_T1, _T2>()
+                 && _TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
+               bool>::type=true>
+
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const _T1& __a1, const _T2& __a2)
 	: _Inherited(__tag, __a, __a1, __a2) { }
 
-      template<typename _Alloc, bool _Dummy = true,
-	       _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _Dummy = void,
+               typename enable_if<
+                 _TCC<_Dummy>::template
+                   _ConstructibleTuple<_T1, _T2>()
+                 && !_TCC<_Dummy>::template
+                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
+               bool>::type=false>
+
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const _T1& __a1, const _T2& __a2)
 	: _Inherited(__tag, __a, __a1, __a2) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ImplicitCtor<true, _U1, _U2> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 	: _Inherited(__tag, __a, std::forward<_U1>(__a1),
 	             std::forward<_U2>(__a2)) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ExplicitCtor<true, _U1, _U2> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
-	      _U1&& __a1, _U2&& __a2)
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
+                       _U1&& __a1, _U2&& __a2)
 	: _Inherited(__tag, __a, std::forward<_U1>(__a1),
 	             std::forward<_U2>(__a2)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
 
       template<typename _Alloc>
-	_GLIBCXX20_CONSTEXPR
 	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const tuple<_U1, _U2>& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 	{ }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const tuple<_U1, _U2>& __in)
 	: _Inherited(__tag, __a,
 	             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 	{ }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ImplicitCtor<true, _U1, _U2> = true>
-	_GLIBCXX20_CONSTEXPR
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
 	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 	{ }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ExplicitCtor<true, _U1, _U2> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+	explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
+                       tuple<_U1, _U2>&& __in)
 	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 	{ }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ImplicitCtor<true, const _U1&, const _U2&> = true>
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const pair<_U1, _U2>& __in)
 	: _Inherited(__tag, __a, __in.first, __in.second) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ExplicitCtor<true, const _U1&, const _U2&> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a,
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _ConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
 	      const pair<_U1, _U2>& __in)
 	: _Inherited(__tag, __a, __in.first, __in.second) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ImplicitCtor<true, _U1, _U2> = true>
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && _TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = true>
+        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
 		     std::forward<_U2>(__in.second)) { }
 
-      template<typename _Alloc, typename _U1, typename _U2,
-	       _ExplicitCtor<true, _U1, _U2> = false>
-	explicit
-	_GLIBCXX20_CONSTEXPR
-	tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
+      template<typename _Alloc, typename _U1, typename _U2, typename
+        enable_if<_TMC::template
+                    _MoveConstructibleTuple<_U1, _U2>()
+                  && !_TMC::template
+                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
+	bool>::type = false>
+        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
+                       pair<_U1, _U2>&& __in)
 	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
 		     std::forward<_U2>(__in.second)) { }
 
-      // Tuple assignment.
-
-      _GLIBCXX20_CONSTEXPR
       tuple&
-      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
-				     const tuple&,
-				     const __nonesuch&>::type __in)
-      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
+      operator=(const tuple& __in)
       {
-	this->_M_assign(__in);
+	static_cast<_Inherited&>(*this) = __in;
 	return *this;
       }
 
-      _GLIBCXX20_CONSTEXPR
       tuple&
-      operator=(typename conditional<__assignable<_T1, _T2>(),
-				     tuple&&,
-				     __nonesuch&&>::type __in)
-      noexcept(__nothrow_assignable<_T1, _T2>())
+      operator=(tuple&& __in)
+      noexcept(is_nothrow_move_assignable<_Inherited>::value)
       {
-	this->_M_assign(std::move(__in));
+	static_cast<_Inherited&>(*this) = std::move(__in);
 	return *this;
       }
 
       template<typename _U1, typename _U2>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
-	operator=(const tuple<_U1, _U2>& __in)
-	noexcept(__nothrow_assignable<const _U1&, const _U2&>())
-	{
-	  this->_M_assign(__in);
+        tuple&
+        operator=(const tuple<_U1, _U2>& __in)
+        {
+	  static_cast<_Inherited&>(*this) = __in;
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<_U1, _U2>(), tuple&>
-	operator=(tuple<_U1, _U2>&& __in)
-	noexcept(__nothrow_assignable<_U1, _U2>())
-	{
-	  this->_M_assign(std::move(__in));
+        tuple&
+        operator=(tuple<_U1, _U2>&& __in)
+        {
+	  static_cast<_Inherited&>(*this) = std::move(__in);
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
-	operator=(const pair<_U1, _U2>& __in)
-	noexcept(__nothrow_assignable<const _U1&, const _U2&>())
-	{
+        tuple&
+        operator=(const pair<_U1, _U2>& __in)
+        {
 	  this->_M_head(*this) = __in.first;
 	  this->_M_tail(*this)._M_head(*this) = __in.second;
 	  return *this;
 	}
 
       template<typename _U1, typename _U2>
-	_GLIBCXX20_CONSTEXPR
-	__enable_if_t<__assignable<_U1, _U2>(), tuple&>
-	operator=(pair<_U1, _U2>&& __in)
-	noexcept(__nothrow_assignable<_U1, _U2>())
-	{
+        tuple&
+        operator=(pair<_U1, _U2>&& __in)
+        {
 	  this->_M_head(*this) = std::forward<_U1>(__in.first);
 	  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
 	  return *this;
 	}
 
-      _GLIBCXX20_CONSTEXPR
       void
       swap(tuple& __in)
-      noexcept(__and_<__is_nothrow_swappable<_T1>,
-		      __is_nothrow_swappable<_T2>>::value)
+      noexcept(noexcept(__in._M_swap(__in)))
       { _Inherited::_M_swap(__in); }
     };
 
@@ -1327,7 +1264,7 @@
   /// class tuple_size
   template<typename... _Elements>
     struct tuple_size<tuple<_Elements...>>
-    : public integral_constant<size_t, sizeof...(_Elements)> { };
+    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
 
 #if __cplusplus > 201402L
   template <typename _Tp>
@@ -1338,7 +1275,7 @@
    * Recursive case for tuple_element: strip off the first element in
    * the tuple and retrieve the (i-1)th element of the remaining tuple.
    */
-  template<size_t __i, typename _Head, typename... _Tail>
+  template<std::size_t __i, typename _Head, typename... _Tail>
     struct tuple_element<__i, tuple<_Head, _Tail...> >
     : tuple_element<__i - 1, tuple<_Tail...> > { };
 
@@ -1358,124 +1295,87 @@
     struct tuple_element<__i, tuple<>>
     {
       static_assert(__i < tuple_size<tuple<>>::value,
-	  "tuple index must be in range");
+	  "tuple index is in range");
     };
 
-  template<size_t __i, typename _Head, typename... _Tail>
+  template<std::size_t __i, typename _Head, typename... _Tail>
     constexpr _Head&
     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
     { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 
-  template<size_t __i, typename _Head, typename... _Tail>
+  template<std::size_t __i, typename _Head, typename... _Tail>
     constexpr const _Head&
     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
     { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 
-  // Deleted overload to improve diagnostics for invalid indices
-  template<size_t __i, typename... _Types>
-    __enable_if_t<(__i >= sizeof...(_Types))>
-    __get_helper(const tuple<_Types...>&) = delete;
-
   /// Return a reference to the ith element of a tuple.
-  template<size_t __i, typename... _Elements>
+  template<std::size_t __i, typename... _Elements>
     constexpr __tuple_element_t<__i, tuple<_Elements...>>&
     get(tuple<_Elements...>& __t) noexcept
     { return std::__get_helper<__i>(__t); }
 
   /// Return a const reference to the ith element of a const tuple.
-  template<size_t __i, typename... _Elements>
+  template<std::size_t __i, typename... _Elements>
     constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
     get(const tuple<_Elements...>& __t) noexcept
     { return std::__get_helper<__i>(__t); }
 
   /// Return an rvalue reference to the ith element of a tuple rvalue.
-  template<size_t __i, typename... _Elements>
+  template<std::size_t __i, typename... _Elements>
     constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
     get(tuple<_Elements...>&& __t) noexcept
     {
       typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
-      return std::forward<__element_type>(std::__get_helper<__i>(__t));
+      return std::forward<__element_type&&>(std::get<__i>(__t));
     }
 
   /// Return a const rvalue reference to the ith element of a const tuple rvalue.
-  template<size_t __i, typename... _Elements>
+  template<std::size_t __i, typename... _Elements>
     constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
     get(const tuple<_Elements...>&& __t) noexcept
     {
       typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
-      return std::forward<const __element_type>(std::__get_helper<__i>(__t));
+      return std::forward<const __element_type&&>(std::get<__i>(__t));
     }
 
-#if __cplusplus >= 201402L
+#if __cplusplus > 201103L
 
 #define __cpp_lib_tuples_by_type 201304
 
-  // Return the index of _Tp in _Types, if it occurs exactly once.
-  // Otherwise, return sizeof...(_Types).
-  // TODO reuse this for __detail::__variant::__exactly_once.
-  template<typename _Tp, typename... _Types>
-    constexpr size_t
-    __find_uniq_type_in_pack()
-    {
-      constexpr size_t __sz = sizeof...(_Types);
-      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
-      size_t __n = __sz;
-      for (size_t __i = 0; __i < __sz; ++__i)
-	{
-	  if (__found[__i])
-	    {
-	      if (__n < __sz) // more than one _Tp found
-		return __sz;
-	      __n = __i;
-	    }
-	}
-      return __n;
-    }
+  template<typename _Head, size_t __i, typename... _Tail>
+    constexpr _Head&
+    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
+    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
+
+  template<typename _Head, size_t __i, typename... _Tail>
+    constexpr const _Head&
+    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
+    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
 
   /// Return a reference to the unique element of type _Tp of a tuple.
   template <typename _Tp, typename... _Types>
     constexpr _Tp&
     get(tuple<_Types...>& __t) noexcept
-    {
-      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
-      static_assert(__idx < sizeof...(_Types),
-	  "the type T in std::get<T> must occur exactly once in the tuple");
-      return std::__get_helper<__idx>(__t);
-    }
+    { return std::__get_helper2<_Tp>(__t); }
 
   /// Return a reference to the unique element of type _Tp of a tuple rvalue.
   template <typename _Tp, typename... _Types>
     constexpr _Tp&&
     get(tuple<_Types...>&& __t) noexcept
-    {
-      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
-      static_assert(__idx < sizeof...(_Types),
-	  "the type T in std::get<T> must occur exactly once in the tuple");
-      return std::forward<_Tp>(std::__get_helper<__idx>(__t));
-    }
+    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }
 
   /// Return a const reference to the unique element of type _Tp of a tuple.
   template <typename _Tp, typename... _Types>
     constexpr const _Tp&
     get(const tuple<_Types...>& __t) noexcept
-    {
-      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
-      static_assert(__idx < sizeof...(_Types),
-	  "the type T in std::get<T> must occur exactly once in the tuple");
-      return std::__get_helper<__idx>(__t);
-    }
+    { return std::__get_helper2<_Tp>(__t); }
 
   /// Return a const reference to the unique element of type _Tp of
   /// a const tuple rvalue.
   template <typename _Tp, typename... _Types>
     constexpr const _Tp&&
     get(const tuple<_Types...>&& __t) noexcept
-    {
-      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
-      static_assert(__idx < sizeof...(_Types),
-	  "the type T in std::get<T> must occur exactly once in the tuple");
-      return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
-    }
+    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }
 #endif
 
   // This class performs the comparison operations on tuples
@@ -1521,35 +1421,6 @@
       return __compare::__eq(__t, __u);
     }
 
-#if __cpp_lib_three_way_comparison
-  template<typename _Cat, typename _Tp, typename _Up>
-    constexpr _Cat
-    __tuple_cmp(const _Tp&, const _Up&, index_sequence<>)
-    { return _Cat::equivalent; }
-
-  template<typename _Cat, typename _Tp, typename _Up,
-	   size_t _Idx0, size_t... _Idxs>
-    constexpr _Cat
-    __tuple_cmp(const _Tp& __t, const _Up& __u,
-		index_sequence<_Idx0, _Idxs...>)
-    {
-      auto __c
-	= __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
-      if (__c != 0)
-	return __c;
-      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
-    }
-
-  template<typename... _Tps, typename... _Ups>
-    constexpr
-    common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>
-    operator<=>(const tuple<_Tps...>& __t, const tuple<_Ups...>& __u)
-    {
-      using _Cat
-	= common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
-      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
-    }
-#else
   template<typename... _TElements, typename... _UElements>
     constexpr bool
     operator<(const tuple<_TElements...>& __t,
@@ -1586,7 +1457,6 @@
     operator>=(const tuple<_TElements...>& __t,
 	       const tuple<_UElements...>& __u)
     { return !(__t < __u); }
-#endif // three_way_comparison
 
   // NB: DR 705.
   template<typename... _Elements>
@@ -1600,7 +1470,6 @@
 
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2275. Why is forward_as_tuple not constexpr?
-  /// std::forward_as_tuple
   template<typename... _Elements>
     constexpr tuple<_Elements&&...>
     forward_as_tuple(_Elements&&... __args) noexcept
@@ -1616,7 +1485,7 @@
 			_Tuple, _Nm>
     { };
 
-  template<size_t _Nm, typename _Tuple, typename... _Tp>
+  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
     struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
     {
       typedef tuple<_Tp...> __type;
@@ -1624,13 +1493,14 @@
 
   template<typename _Tuple>
     struct __do_make_tuple
-    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>
+    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
     { };
 
   // Returns the std::tuple equivalent of a tuple-like type.
   template<typename _Tuple>
     struct __make_tuple
-    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
+    : public __do_make_tuple<typename std::remove_cv
+            <typename std::remove_reference<_Tuple>::type>::type>
     { };
 
   // Combines several std::tuple's into a single one.
@@ -1672,14 +1542,14 @@
   template<>
     struct __make_1st_indices<>
     {
-      typedef _Index_tuple<> __type;
+      typedef std::_Index_tuple<> __type;
     };
 
   template<typename _Tp, typename... _Tpls>
     struct __make_1st_indices<_Tp, _Tpls...>
     {
-      typedef typename _Build_index_tuple<tuple_size<
-	typename remove_reference<_Tp>::type>::value>::__type __type;
+      typedef typename std::_Build_index_tuple<std::tuple_size<
+	typename std::remove_reference<_Tp>::type>::value>::__type __type;
     };
 
   // Performs the actual concatenation by step-wise expanding tuple-like
@@ -1688,8 +1558,8 @@
   template<typename _Ret, typename _Indices, typename... _Tpls>
     struct __tuple_concater;
 
-  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
-    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>
+  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
+    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
     {
       template<typename... _Us>
         static constexpr _Ret
@@ -1704,7 +1574,7 @@
     };
 
   template<typename _Ret>
-    struct __tuple_concater<_Ret, _Index_tuple<>>
+    struct __tuple_concater<_Ret, std::_Index_tuple<>>
     {
       template<typename... _Us>
 	static constexpr _Ret
@@ -1737,7 +1607,6 @@
 
   /// swap
   template<typename... _Elements>
-    _GLIBCXX20_CONSTEXPR
     inline
 #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
     // Constrained free swap overload, see p0185r1
@@ -1752,7 +1621,6 @@
 
 #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
   template<typename... _Elements>
-    _GLIBCXX20_CONSTEXPR
     typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
     swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;
 #endif
@@ -1778,17 +1646,8 @@
     struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
 
   // See stl_pair.h...
-  /** "piecewise construction" using a tuple of arguments for each member.
-   *
-   * @param __first Arguments for the first member of the pair.
-   * @param __second Arguments for the second member of the pair.
-   *
-   * The elements of each tuple will be used as the constructor arguments
-   * for the data members of the pair.
-  */
   template<class _T1, class _T2>
     template<typename... _Args1, typename... _Args2>
-      _GLIBCXX20_CONSTEXPR
       inline
       pair<_T1, _T2>::
       pair(piecewise_construct_t,
@@ -1799,41 +1658,17 @@
       { }
 
   template<class _T1, class _T2>
-    template<typename... _Args1, size_t... _Indexes1,
-	     typename... _Args2, size_t... _Indexes2>
-      _GLIBCXX20_CONSTEXPR inline
+    template<typename... _Args1, std::size_t... _Indexes1,
+             typename... _Args2, std::size_t... _Indexes2>
+      inline
       pair<_T1, _T2>::
       pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
 	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
       : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
-	second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
+        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
       { }
 
-#if __cplusplus >= 201703L
-
-  // Unpack a std::tuple into a type trait and use its value.
-  // For cv std::tuple<_Up> the result is _Trait<_Tp, cv _Up...>::value.
-  // For cv std::tuple<_Up>& the result is _Trait<_Tp, cv _Up&...>::value.
-  // Otherwise the result is false (because we don't know if std::get throws).
-  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
-    inline constexpr bool __unpack_std_tuple = false;
-
-  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
-    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
-      = _Trait<_Tp, _Up...>::value;
-
-  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
-    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
-      = _Trait<_Tp, _Up&...>::value;
-
-  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
-    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
-      = _Trait<_Tp, const _Up...>::value;
-
-  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
-    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
-      = _Trait<_Tp, const _Up&...>::value;
-
+#if __cplusplus > 201402L
 # define __cpp_lib_apply 201603
 
   template <typename _Fn, typename _Tuple, size_t... _Idx>
@@ -1847,10 +1682,8 @@
   template <typename _Fn, typename _Tuple>
     constexpr decltype(auto)
     apply(_Fn&& __f, _Tuple&& __t)
-    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
     {
-      using _Indices
-	= make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
+      using _Indices = make_index_sequence<tuple_size_v<decay_t<_Tuple>>>;
       return std::__apply_impl(std::forward<_Fn>(__f),
 			       std::forward<_Tuple>(__t),
 			       _Indices{});
@@ -1866,11 +1699,10 @@
   template <typename _Tp, typename _Tuple>
     constexpr _Tp
     make_from_tuple(_Tuple&& __t)
-    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
     {
       return __make_from_tuple_impl<_Tp>(
         std::forward<_Tuple>(__t),
-	make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
+	make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{});
     }
 #endif // C++17
 
