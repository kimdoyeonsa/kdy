--- a/libstdc++-v3/src/c++98/locale_init.cc	2021-07-28 15:55:09.340315000 +0900
+++ b/libstdc++-v3/src/c++98/locale_init.cc	2021-06-01 16:53:06.880501000 +0900
@@ -1,4 +1,4 @@
-// Copyright (C) 1997-2021 Free Software Foundation, Inc.
+// Copyright (C) 1997-2019 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -57,16 +57,8 @@
 
 namespace
 {
-  const int num_facets = (
-      _GLIBCXX_NUM_FACETS + _GLIBCXX_NUM_CXX11_FACETS
-#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT
-      + _GLIBCXX_NUM_LBDL_ALT128_FACETS
-#endif
-      )
-#ifdef _GLIBCXX_USE_WCHAR_T
-    * 2
-#endif
-    + _GLIBCXX_NUM_UNICODE_FACETS;
+  const int num_facets = _GLIBCXX_NUM_FACETS + _GLIBCXX_NUM_UNICODE_FACETS
+    + (_GLIBCXX_USE_DUAL_ABI ? _GLIBCXX_NUM_CXX11_FACETS : 0);
 
   __gnu_cxx::__mutex&
   get_locale_mutex()
@@ -567,10 +559,6 @@
 
 #endif
 
-#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT
-    _M_init_extra_ldbl128(true);
-#endif
-
 #if _GLIBCXX_USE_DUAL_ABI
     facet* extra[] = { __npc, __mpcf, __mpct
 # ifdef  _GLIBCXX_USE_WCHAR_T
@@ -578,7 +566,6 @@
 # endif
     };
 
-    // This call must be after creating all facets, as it sets caches.
     _M_init_extra(extra);
 #endif
 
--- a/libstdc++-v3/include/bits/locale_conv.h	2021-07-28 15:55:09.280315000 +0900
+++ b/libstdc++-v3/include/bits/locale_conv.h	2021-06-01 16:53:06.828501000 +0900
@@ -78,7 +78,7 @@
 	  __outchars = __outnext - &__outstr.front();
 	}
       while (__result == codecvt_base::partial && __next != __last
-	     && ptrdiff_t(__outstr.size() - __outchars) < __maxlen);
+	     && (__outstr.size() - __outchars) < __maxlen);
 
       if (__result == codecvt_base::error)
 	{
@@ -142,7 +142,7 @@
       _State __state = {};
       size_t __n;
       return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n)
-	&& (__n == size_t(__last - __first));
+	&& (__n == (__last - __first));
     }
 
   // Convert wide character string to narrow.
@@ -185,7 +185,7 @@
       _State __state = {};
       size_t __n;
       return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n)
-	&& (__n == size_t(__last - __first));
+	&& (__n == (__last - __first));
     }
 
 #ifdef _GLIBCXX_USE_CHAR8_T
--- a/libstdc++-v3/include/bits/unique_ptr.h	2021-07-28 15:55:09.288315000 +0900
+++ b/libstdc++-v3/include/bits/unique_ptr.h	2021-06-01 16:53:06.836501000 +0900
@@ -37,10 +37,6 @@
 #include <tuple>
 #include <bits/stl_function.h>
 #include <bits/functional_hash.h>
-#if __cplusplus > 201703L
-# include <compare>
-# include <ostream>
-#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
@@ -58,7 +54,7 @@
 #pragma GCC diagnostic pop
 #endif
 
-  /// Primary template of default_delete, used by unique_ptr for single objects
+  /// Primary template of default_delete, used by unique_ptr
   template<typename _Tp>
     struct default_delete
     {
@@ -67,14 +63,14 @@
 
       /** @brief Converting constructor.
        *
-       * Allows conversion from a deleter for objects of another type, `_Up`,
-       * only if `_Up*` is convertible to `_Tp*`.
+       * Allows conversion from a deleter for arrays of another type, @p _Up,
+       * only if @p _Up* is convertible to @p _Tp*.
        */
-      template<typename _Up,
-	       typename = _Require<is_convertible<_Up*, _Tp*>>>
+      template<typename _Up, typename = typename
+	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
         default_delete(const default_delete<_Up>&) noexcept { }
 
-      /// Calls `delete __ptr`
+      /// Calls @c delete @p __ptr
       void
       operator()(_Tp* __ptr) const
       {
@@ -88,8 +84,7 @@
 
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // DR 740 - omit specialization for array objects with a compile time length
-
-  /// Specialization of default_delete for arrays, used by `unique_ptr<T[]>`
+  /// Specialization for arrays, default_delete.
   template<typename _Tp>
     struct default_delete<_Tp[]>
     {
@@ -100,30 +95,27 @@
       /** @brief Converting constructor.
        *
        * Allows conversion from a deleter for arrays of another type, such as
-       * a const-qualified version of `_Tp`.
+       * a const-qualified version of @p _Tp.
        *
-       * Conversions from types derived from `_Tp` are not allowed because
-       * it is undefined to `delete[]` an array of derived types through a
+       * Conversions from types derived from @c _Tp are not allowed because
+       * it is unsafe to @c delete[] an array of derived types through a
        * pointer to the base type.
        */
-      template<typename _Up,
-	       typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
+      template<typename _Up, typename = typename
+	       enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
         default_delete(const default_delete<_Up[]>&) noexcept { }
 
-      /// Calls `delete[] __ptr`
+      /// Calls @c delete[] @p __ptr
       template<typename _Up>
-	typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
+      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 	operator()(_Up* __ptr) const
-	{
-	  static_assert(sizeof(_Tp)>0,
-			"can't delete pointer to incomplete type");
-	  delete [] __ptr;
-	}
+      {
+	static_assert(sizeof(_Tp)>0,
+		      "can't delete pointer to incomplete type");
+	delete [] __ptr;
+      }
     };
 
-  /// @cond undocumented
-
-  // Manages the pointer and deleter of a unique_ptr
   template <typename _Tp, typename _Dp>
     class __uniq_ptr_impl
     {
@@ -158,37 +150,11 @@
       __uniq_ptr_impl(pointer __p, _Del&& __d)
 	: _M_t(__p, std::forward<_Del>(__d)) { }
 
-      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
-      : _M_t(std::move(__u._M_t))
-      { __u._M_ptr() = nullptr; }
-
-      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
-      {
-	reset(__u.release());
-	_M_deleter() = std::forward<_Dp>(__u._M_deleter());
-	return *this;
-      }
-
       pointer&   _M_ptr() { return std::get<0>(_M_t); }
       pointer    _M_ptr() const { return std::get<0>(_M_t); }
       _Dp&       _M_deleter() { return std::get<1>(_M_t); }
       const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
 
-      void reset(pointer __p) noexcept
-      {
-	const pointer __old_p = _M_ptr();
-	_M_ptr() = __p;
-	if (__old_p)
-	  _M_deleter()(__old_p);
-      }
-
-      pointer release() noexcept
-      {
-	pointer __p = _M_ptr();
-	_M_ptr() = nullptr;
-	return __p;
-      }
-
       void
       swap(__uniq_ptr_impl& __rhs) noexcept
       {
@@ -201,42 +167,6 @@
       tuple<pointer, _Dp> _M_t;
     };
 
-  // Defines move construction + assignment as either defaulted or deleted.
-  template <typename _Tp, typename _Dp,
-	    bool = is_move_constructible<_Dp>::value,
-	    bool = is_move_assignable<_Dp>::value>
-    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
-    {
-      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
-      __uniq_ptr_data(__uniq_ptr_data&&) = default;
-      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
-    };
-
-  template <typename _Tp, typename _Dp>
-    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
-    {
-      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
-      __uniq_ptr_data(__uniq_ptr_data&&) = default;
-      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
-    };
-
-  template <typename _Tp, typename _Dp>
-    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
-    {
-      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
-      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
-      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
-    };
-
-  template <typename _Tp, typename _Dp>
-    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
-    {
-      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
-      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
-      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
-    };
-  /// @endcond
-
   /// 20.7.1.2 unique_ptr for single objects.
   template <typename _Tp, typename _Dp = default_delete<_Tp>>
     class unique_ptr
@@ -245,7 +175,7 @@
 	using _DeleterConstraint =
 	  typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
 
-      __uniq_ptr_data<_Tp, _Dp> _M_t;
+      __uniq_ptr_impl<_Tp, _Dp> _M_t;
 
     public:
       using pointer	  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
@@ -324,7 +254,8 @@
       // Move constructors.
 
       /// Move constructor.
-      unique_ptr(unique_ptr&&) = default;
+      unique_ptr(unique_ptr&& __u) noexcept
+      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
 
       /** @brief Converting constructor from another type
        *
@@ -366,16 +297,24 @@
 
       /** @brief Move assignment operator.
        *
-       * Invokes the deleter if this object owns a pointer.
+       * @param __u  The object to transfer ownership from.
+       *
+       * Invokes the deleter first if this object owns a pointer.
        */
-      unique_ptr& operator=(unique_ptr&&) = default;
+      unique_ptr&
+      operator=(unique_ptr&& __u) noexcept
+      {
+	reset(__u.release());
+	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
+	return *this;
+      }
 
       /** @brief Assignment from another type.
        *
        * @param __u  The object to transfer ownership from, which owns a
        *             convertible pointer to a non-array object.
        *
-       * Invokes the deleter if this object owns a pointer.
+       * Invokes the deleter first if this object owns a pointer.
        */
       template<typename _Up, typename _Ep>
         typename enable_if< __and_<
@@ -440,7 +379,11 @@
       /// Release ownership of any stored pointer.
       pointer
       release() noexcept
-      { return _M_t.release(); }
+      {
+	pointer __p = get();
+	_M_t._M_ptr() = pointer();
+	return __p;
+      }
 
       /** @brief Replace the stored pointer.
        *
@@ -453,7 +396,10 @@
       {
 	static_assert(__is_invocable<deleter_type&, pointer>::value,
 		      "unique_ptr's deleter must be invocable with a pointer");
-	_M_t.reset(std::move(__p));
+	using std::swap;
+	swap(_M_t._M_ptr(), __p);
+	if (__p != pointer())
+	  get_deleter()(std::move(__p));
       }
 
       /// Exchange the pointer and deleter with another object.
@@ -480,7 +426,7 @@
       using _DeleterConstraint =
 	typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;
 
-      __uniq_ptr_data<_Tp, _Dp> _M_t;
+      __uniq_ptr_impl<_Tp, _Dp> _M_t;
 
       template<typename _Up>
 	using __remove_cv = typename remove_cv<_Up>::type;
@@ -587,7 +533,8 @@
 				 _DelUnref&&>) = delete;
 
       /// Move constructor.
-      unique_ptr(unique_ptr&&) = default;
+      unique_ptr(unique_ptr&& __u) noexcept
+      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
 
       /// Creates a unique_ptr that owns nothing.
       template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
@@ -617,17 +564,24 @@
 
       /** @brief Move assignment operator.
        *
-       * Invokes the deleter if this object owns a pointer.
+       * @param __u  The object to transfer ownership from.
+       *
+       * Invokes the deleter first if this object owns a pointer.
        */
       unique_ptr&
-      operator=(unique_ptr&&) = default;
+      operator=(unique_ptr&& __u) noexcept
+      {
+	reset(__u.release());
+	get_deleter() = std::forward<deleter_type>(__u.get_deleter());
+	return *this;
+      }
 
       /** @brief Assignment from another type.
        *
        * @param __u  The object to transfer ownership from, which owns a
        *             convertible pointer to an array object.
        *
-       * Invokes the deleter if this object owns a pointer.
+       * Invokes the deleter first if this object owns a pointer.
        */
       template<typename _Up, typename _Ep>
 	typename
@@ -684,7 +638,11 @@
       /// Release ownership of any stored pointer.
       pointer
       release() noexcept
-      { return _M_t.release(); }
+      {
+	pointer __p = get();
+	_M_t._M_ptr() = pointer();
+	return __p;
+      }
 
       /** @brief Replace the stored pointer.
        *
@@ -706,10 +664,18 @@
                >>
       void
       reset(_Up __p) noexcept
-      { _M_t.reset(std::move(__p)); }
+      {
+	pointer __ptr = __p;
+	using std::swap;
+	swap(_M_t._M_ptr(), __ptr);
+	if (__ptr != nullptr)
+	  get_deleter()(__ptr);
+      }
 
       void reset(nullptr_t = nullptr) noexcept
-      { reset(pointer()); }
+      {
+        reset(pointer());
+      }
 
       /// Exchange the pointer and deleter with another object.
       void
@@ -724,9 +690,6 @@
       unique_ptr& operator=(const unique_ptr&) = delete;
     };
 
-  /// @relates unique_ptr @{
-
-  /// Swap overload for unique_ptr
   template<typename _Tp, typename _Dp>
     inline
 #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
@@ -746,7 +709,6 @@
 	 unique_ptr<_Tp, _Dp>&) = delete;
 #endif
 
-  /// Equality operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -754,20 +716,16 @@
 	       const unique_ptr<_Up, _Ep>& __y)
     { return __x.get() == __y.get(); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
     { return !__x; }
 
-#ifndef __cpp_lib_three_way_comparison
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
     { return !__x; }
 
-  /// Inequality operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -775,20 +733,16 @@
 	       const unique_ptr<_Up, _Ep>& __y)
     { return __x.get() != __y.get(); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
     { return (bool)__x; }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
     { return (bool)__x; }
-#endif // three way comparison
 
-  /// Relational operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -801,25 +755,18 @@
       return std::less<_CT>()(__x.get(), __y.get());
     }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
-    {
-      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
-								 nullptr);
-    }
+    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
+								 nullptr); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
-    {
-      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
-								 __x.get());
-    }
+    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
+								 __x.get()); }
 
-  /// Relational operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -827,19 +774,16 @@
 	       const unique_ptr<_Up, _Ep>& __y)
     { return !(__y < __x); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     { return !(nullptr < __x); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     { return !(__x < nullptr); }
 
-  /// Relational operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -847,25 +791,18 @@
 	      const unique_ptr<_Up, _Ep>& __y)
     { return (__y < __x); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
-    {
-      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
-								 __x.get());
-    }
+    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
+								 __x.get()); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
-    {
-      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
-								 nullptr);
-    }
+    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
+								 nullptr); }
 
-  /// Relational operator for unique_ptr objects, compares the owned pointers
   template<typename _Tp, typename _Dp,
 	   typename _Up, typename _Ep>
     _GLIBCXX_NODISCARD inline bool
@@ -873,74 +810,34 @@
 	       const unique_ptr<_Up, _Ep>& __y)
     { return !(__x < __y); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
     { return !(__x < nullptr); }
 
-  /// unique_ptr comparison with nullptr
   template<typename _Tp, typename _Dp>
     _GLIBCXX_NODISCARD inline bool
     operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
     { return !(nullptr < __x); }
 
-#ifdef __cpp_lib_three_way_comparison
-  template<typename _Tp, typename _Dp, typename _Up, typename _Ep>
-    requires three_way_comparable_with<typename unique_ptr<_Tp, _Dp>::pointer,
-				       typename unique_ptr<_Up, _Ep>::pointer>
-    inline
-    compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer,
-			       typename unique_ptr<_Up, _Ep>::pointer>
-    operator<=>(const unique_ptr<_Tp, _Dp>& __x,
-		const unique_ptr<_Up, _Ep>& __y)
-    { return compare_three_way()(__x.get(), __y.get()); }
-
+  /// std::hash specialization for unique_ptr.
   template<typename _Tp, typename _Dp>
-    requires three_way_comparable<typename unique_ptr<_Tp, _Dp>::pointer>
-    inline
-    compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer>
-    operator<=>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
-    {
-      using pointer = typename unique_ptr<_Tp, _Dp>::pointer;
-      return compare_three_way()(__x.get(), static_cast<pointer>(nullptr));
-    }
-#endif
-  /// @} relates unique_ptr
-
-  /// @cond undocumented
-  template<typename _Up, typename _Ptr = typename _Up::pointer,
-	   bool = __poison_hash<_Ptr>::__enable_hash_call>
-    struct __uniq_ptr_hash
-#if ! _GLIBCXX_INLINE_VERSION
-    : private __poison_hash<_Ptr>
-#endif
+    struct hash<unique_ptr<_Tp, _Dp>>
+    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
+    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>
     {
       size_t
-      operator()(const _Up& __u) const
-      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
-      { return hash<_Ptr>()(__u.get()); }
+      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
+      {
+	typedef unique_ptr<_Tp, _Dp> _UP;
+	return std::hash<typename _UP::pointer>()(__u.get());
+      }
     };
 
-  template<typename _Up, typename _Ptr>
-    struct __uniq_ptr_hash<_Up, _Ptr, false>
-    : private __poison_hash<_Ptr>
-    { };
-  /// @endcond
+#if __cplusplus > 201103L
 
-  /// std::hash specialization for unique_ptr.
-  template<typename _Tp, typename _Dp>
-    struct hash<unique_ptr<_Tp, _Dp>>
-    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
-      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
-    { };
-
-#if __cplusplus >= 201402L
-  /// @relates unique_ptr @{
 #define __cpp_lib_make_unique 201304
 
-  /// @cond undocumented
-
   template<typename _Tp>
     struct _MakeUniq
     { typedef unique_ptr<_Tp> __single_object; };
@@ -953,8 +850,6 @@
     struct _MakeUniq<_Tp[_Bound]>
     { struct __invalid_type { }; };
 
-  /// @endcond
-
   /// std::make_unique for single objects
   template<typename _Tp, typename... _Args>
     inline typename _MakeUniq<_Tp>::__single_object
@@ -969,45 +864,9 @@
 
   /// Disable std::make_unique for arrays of known bound
   template<typename _Tp, typename... _Args>
-    typename _MakeUniq<_Tp>::__invalid_type
+    inline typename _MakeUniq<_Tp>::__invalid_type
     make_unique(_Args&&...) = delete;
-
-#if __cplusplus > 201703L
-  /// std::make_unique_for_overwrite for single objects
-  template<typename _Tp>
-    inline typename _MakeUniq<_Tp>::__single_object
-    make_unique_for_overwrite()
-    { return unique_ptr<_Tp>(new _Tp); }
-
-  /// std::make_unique_for_overwrite for arrays of unknown bound
-  template<typename _Tp>
-    inline typename _MakeUniq<_Tp>::__array
-    make_unique_for_overwrite(size_t __n)
-    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__n]); }
-
-  /// Disable std::make_unique_for_overwrite for arrays of known bound
-  template<typename _Tp, typename... _Args>
-    typename _MakeUniq<_Tp>::__invalid_type
-    make_unique_for_overwrite(_Args&&...) = delete;
-#endif // C++20
-
-  /// @} relates unique_ptr
-#endif // C++14
-
-#if __cplusplus > 201703L && __cpp_concepts
-  // _GLIBCXX_RESOLVE_LIB_DEFECTS
-  // 2948. unique_ptr does not define operator<< for stream output
-  /// Stream output operator for unique_ptr
-  template<typename _CharT, typename _Traits, typename _Tp, typename _Dp>
-    inline basic_ostream<_CharT, _Traits>&
-    operator<<(basic_ostream<_CharT, _Traits>& __os,
-	       const unique_ptr<_Tp, _Dp>& __p)
-    requires requires { __os << __p.get(); }
-    {
-      __os << __p.get();
-      return __os;
-    }
-#endif // C++20
+#endif
 
   /// @} group pointer_abstractions
 

