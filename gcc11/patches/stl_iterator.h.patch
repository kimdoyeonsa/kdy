--- a/libstdc++-v3/include/bits/stl_iterator.h	2021-07-28 15:55:09.288315000 +0900
+++ b/libstdc++-v3/include/bits/stl_iterator.h	2021-04-08 20:56:30.357768000 +0900
@@ -61,7 +61,6 @@
 #define _STL_ITERATOR_H 1
 
 #include <bits/cpp_type_traits.h>
-#include <bits/stl_iterator_base_types.h>
 #include <ext/type_traits.h>
 #include <bits/move.h>
 #include <bits/ptr_traits.h>
@@ -80,7 +79,6 @@
 #if __cplusplus > 201703L
 # include <compare>
 # include <new>
-# include <bits/exception_defines.h>
 # include <bits/iterator_concepts.h>
 #endif
 
@@ -131,17 +129,6 @@
 		      typename iterator_traits<_Iterator>::pointer,
                       typename iterator_traits<_Iterator>::reference>
     {
-      template<typename _Iter>
-	friend class reverse_iterator;
-
-#if __cpp_lib_concepts
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
-      template<typename _Iter>
-	static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
-	    && convertible_to<const _Iter&, _Iterator>;
-#endif
-
     protected:
       _Iterator current;
 
@@ -149,11 +136,11 @@
 
     public:
       typedef _Iterator					iterator_type;
-      typedef typename __traits_type::pointer		pointer;
-#if __cplusplus <= 201703L
       typedef typename __traits_type::difference_type	difference_type;
+      typedef typename __traits_type::pointer		pointer;
       typedef typename __traits_type::reference		reference;
-#else
+
+#if __cplusplus > 201703L && __cpp_lib_concepts
       using iterator_concept
 	= conditional_t<random_access_iterator<_Iterator>,
 			random_access_iterator_tag,
@@ -161,9 +148,6 @@
       using iterator_category
 	= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
 				     random_access_iterator_tag>;
-      using value_type = iter_value_t<_Iterator>;
-      using difference_type = iter_difference_t<_Iterator>;
-      using reference = iter_reference_t<_Iterator>;
 #endif
 
       /**
@@ -198,27 +182,9 @@
        *  underlying %iterator can be converted to the type of @c current.
       */
       template<typename _Iter>
-#if __cpp_lib_concepts
-	requires __convertible<_Iter>
-#endif
 	_GLIBCXX17_CONSTEXPR
         reverse_iterator(const reverse_iterator<_Iter>& __x)
-	: current(__x.current) { }
-
-#if __cplusplus >= 201103L
-      template<typename _Iter>
-#if __cpp_lib_concepts
-	requires __convertible<_Iter>
-	  && assignable_from<_Iterator&, const _Iter&>
-#endif
-	_GLIBCXX17_CONSTEXPR
-	reverse_iterator&
-	operator=(const reverse_iterator<_Iter>& __x)
-	{
-	  current = __x.current;
-	  return *this;
-	}
-#endif
+	: current(__x.base()) { }
 
       /**
        *  @return  @c current, the %iterator used for underlying work.
@@ -403,7 +369,7 @@
         { return __t.operator->(); }
     };
 
-  ///@{
+  //@{
   /**
    *  @param  __x  A %reverse_iterator.
    *  @param  __y  A %reverse_iterator.
@@ -452,7 +418,6 @@
 
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // DR 280. Comparison of reverse_iterator to const reverse_iterator.
-
   template<typename _IteratorL, typename _IteratorR>
     inline _GLIBCXX17_CONSTEXPR bool
     operator==(const reverse_iterator<_IteratorL>& __x,
@@ -463,31 +428,31 @@
     inline _GLIBCXX17_CONSTEXPR bool
     operator<(const reverse_iterator<_IteratorL>& __x,
 	      const reverse_iterator<_IteratorR>& __y)
-    { return __x.base() > __y.base(); }
+    { return __y.base() < __x.base(); }
 
   template<typename _IteratorL, typename _IteratorR>
     inline _GLIBCXX17_CONSTEXPR bool
     operator!=(const reverse_iterator<_IteratorL>& __x,
 	       const reverse_iterator<_IteratorR>& __y)
-    { return __x.base() != __y.base(); }
+    { return !(__x == __y); }
 
   template<typename _IteratorL, typename _IteratorR>
     inline _GLIBCXX17_CONSTEXPR bool
     operator>(const reverse_iterator<_IteratorL>& __x,
 	      const reverse_iterator<_IteratorR>& __y)
-    { return __x.base() < __y.base(); }
+    { return __y < __x; }
 
   template<typename _IteratorL, typename _IteratorR>
     inline _GLIBCXX17_CONSTEXPR bool
     operator<=(const reverse_iterator<_IteratorL>& __x,
 	       const reverse_iterator<_IteratorR>& __y)
-    { return __x.base() >= __y.base(); }
+    { return !(__y < __x); }
 
   template<typename _IteratorL, typename _IteratorR>
     inline _GLIBCXX17_CONSTEXPR bool
     operator>=(const reverse_iterator<_IteratorL>& __x,
 	       const reverse_iterator<_IteratorR>& __y)
-    { return __x.base() <= __y.base(); }
+    { return !(__x < __y); }
 #else // C++20
   template<typename _IteratorL, typename _IteratorR>
     constexpr bool
@@ -538,7 +503,7 @@
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
 #endif // C++20
-  ///@}
+  //@}
 
 #if __cplusplus < 201103L
   template<typename _Iterator>
@@ -967,7 +932,7 @@
     { return insert_iterator<_Container>(__x, __i); }
 #endif
 
-  /// @} group iterators
+  // @} group iterators
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
@@ -1305,24 +1270,6 @@
     };
 #endif // C++20
 
-  namespace __detail
-  {
-#if __cplusplus > 201703L && __cpp_lib_concepts
-    template<typename _Iterator>
-      struct __move_iter_cat
-      { };
-
-    template<typename _Iterator>
-      requires requires { typename iterator_traits<_Iterator>::iterator_category; }
-      struct __move_iter_cat<_Iterator>
-      {
-	using iterator_category
-	  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,
-			     random_access_iterator_tag>;
-      };
-#endif
-  }
-
   // 24.4.3  Move iterators
   /**
    *  Class template move_iterator is an iterator adapter with the same
@@ -1334,34 +1281,23 @@
    */
   template<typename _Iterator>
     class move_iterator
-#if __cplusplus > 201703L && __cpp_lib_concepts
-      : public __detail::__move_iter_cat<_Iterator>
-#endif
     {
       _Iterator _M_current;
 
       using __traits_type = iterator_traits<_Iterator>;
-#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
+#if __cplusplus > 201703L && __cpp_lib_concepts
+      using __base_cat = typename __traits_type::iterator_category;
+#else
       using __base_ref = typename __traits_type::reference;
 #endif
 
-      template<typename _Iter2>
-	friend class move_iterator;
-
-#if __cpp_lib_concepts
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
-      template<typename _Iter2>
-	static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
-	    && convertible_to<const _Iter2&, _Iterator>;
-#endif
-
     public:
       using iterator_type = _Iterator;
 
 #if __cplusplus > 201703L && __cpp_lib_concepts
       using iterator_concept = input_iterator_tag;
-      // iterator_category defined in __move_iter_cat
+      using iterator_category
+	= __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;
       using value_type = iter_value_t<_Iterator>;
       using difference_type = iter_difference_t<_Iterator>;
       using pointer = _Iterator;
@@ -1388,22 +1324,15 @@
       : _M_current(std::move(__i)) { }
 
       template<typename _Iter>
-#if __cpp_lib_concepts
-	requires __convertible<_Iter>
-#endif
 	_GLIBCXX17_CONSTEXPR
 	move_iterator(const move_iterator<_Iter>& __i)
-	: _M_current(__i._M_current) { }
+	: _M_current(__i.base()) { }
 
       template<typename _Iter>
-#if __cpp_lib_concepts
-	requires __convertible<_Iter>
-	  && assignable_from<_Iterator&, const _Iter&>
-#endif
 	_GLIBCXX17_CONSTEXPR
 	move_iterator& operator=(const move_iterator<_Iter>& __i)
 	{
-	  _M_current = __i._M_current;
+	  _M_current = __i.base();
 	  return *this;
 	}
 
@@ -1412,8 +1341,11 @@
       base() const
       { return _M_current; }
 #else
-      constexpr const iterator_type&
-      base() const & noexcept
+      constexpr iterator_type
+      base() const &
+#if __cpp_lib_concepts
+	requires copy_constructible<iterator_type>
+#endif
       { return _M_current; }
 
       constexpr iterator_type
@@ -1680,10 +1612,6 @@
 	    || is_reference_v<iter_reference_t<_It>>
 	    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
 
-    template<typename _It>
-      concept __common_iter_use_postfix_proxy
-	= (!requires (_It& __i) { { *__i++ } -> __can_reference; })
-	  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>;
   } // namespace __detail
 
   /// An iterator/sentinel adaptor for representing a non-common range.
@@ -1706,11 +1634,11 @@
       _S_noexcept()
       { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }
 
-    class __arrow_proxy
+    class _Proxy
     {
       iter_value_t<_It> _M_keep;
 
-      __arrow_proxy(iter_reference_t<_It>&& __x)
+      _Proxy(iter_reference_t<_It>&& __x)
       : _M_keep(std::move(__x)) { }
 
       friend class common_iterator;
@@ -1721,21 +1649,6 @@
       { return std::__addressof(_M_keep); }
     };
 
-    class __postfix_proxy
-    {
-      iter_value_t<_It> _M_keep;
-
-      __postfix_proxy(iter_reference_t<_It>&& __x)
-      : _M_keep(std::move(__x)) { }
-
-      friend class common_iterator;
-
-    public:
-      const iter_value_t<_It>&
-      operator*() const
-      { return _M_keep; }
-    };
-
   public:
     constexpr
     common_iterator()
@@ -1892,7 +1805,7 @@
 	  return std::__addressof(__tmp);
 	}
       else
-	return __arrow_proxy{*_M_it};
+	return _Proxy{*_M_it};
     }
 
     common_iterator&
@@ -1913,14 +1826,8 @@
 	  ++*this;
 	  return __tmp;
 	}
-      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
-	return _M_it++;
       else
-	{
-	  __postfix_proxy __p(**this);
-	  ++*this;
-	  return __p;
-	}
+	return _M_it++;
     }
 
     template<typename _It2, sentinel_for<_It> _Sent2>
@@ -2051,21 +1958,12 @@
 	  using type = decltype(std::declval<const _CIter&>().operator->());
 	};
 
-      static auto
-      _S_iter_cat()
-      {
-	using _Traits = iterator_traits<_It>;
-	if constexpr (requires { requires derived_from<typename _Traits::iterator_category,
-						       forward_iterator_tag>; })
-	  return forward_iterator_tag{};
-	else
-	  return input_iterator_tag{};
-      }
-
     public:
       using iterator_concept = conditional_t<forward_iterator<_It>,
 	    forward_iterator_tag, input_iterator_tag>;
-      using iterator_category = decltype(_S_iter_cat());
+      using iterator_category = __detail::__clamp_iter_cat<
+	typename iterator_traits<_It>::iterator_category,
+	forward_iterator_tag, input_iterator_tag>;
       using value_type = iter_value_t<_It>;
       using difference_type = iter_difference_t<_It>;
       using pointer = typename __ptr<_It>::type;
@@ -2074,48 +1972,12 @@
 
   // [iterators.counted] Counted iterators
 
-  namespace __detail
-  {
-    template<typename _It>
-      struct __counted_iter_value_type
-      { };
-
-    template<indirectly_readable _It>
-      struct __counted_iter_value_type<_It>
-      { using value_type = iter_value_t<_It>; };
-
-    template<typename _It>
-      struct __counted_iter_concept
-      { };
-
-    template<typename _It>
-      requires requires { typename _It::iterator_concept; }
-      struct __counted_iter_concept<_It>
-      { using iterator_concept = typename _It::iterator_concept; };
-
-    template<typename _It>
-      struct __counted_iter_cat
-      { };
-
-    template<typename _It>
-      requires requires { typename _It::iterator_category; }
-      struct __counted_iter_cat<_It>
-      { using iterator_category = typename _It::iterator_category; };
-  }
-
   /// An iterator adaptor that keeps track of the distance to the end.
   template<input_or_output_iterator _It>
     class counted_iterator
-      : public __detail::__counted_iter_value_type<_It>,
-	public __detail::__counted_iter_concept<_It>,
-	public __detail::__counted_iter_cat<_It>
     {
     public:
       using iterator_type = _It;
-      // value_type defined in __counted_iter_value_type
-      using difference_type = iter_difference_t<_It>;
-      // iterator_concept defined in __counted_iter_concept
-      // iterator_category defined in __counted_iter_cat
 
       constexpr counted_iterator() = default;
 
@@ -2141,8 +2003,10 @@
 	  return *this;
 	}
 
-      constexpr const _It&
-      base() const & noexcept
+      constexpr _It
+      base() const &
+      noexcept(is_nothrow_copy_constructible_v<_It>)
+      requires copy_constructible<_It>
       { return _M_current; }
 
       constexpr _It
@@ -2156,24 +2020,13 @@
       constexpr decltype(auto)
       operator*()
       noexcept(noexcept(*_M_current))
-      {
-	__glibcxx_assert( _M_length > 0 );
-	return *_M_current;
-      }
+      { return *_M_current; }
 
       constexpr decltype(auto)
       operator*() const
       noexcept(noexcept(*_M_current))
       requires __detail::__dereferenceable<const _It>
-      {
-	__glibcxx_assert( _M_length > 0 );
-	return *_M_current;
-      }
-
-      constexpr auto
-      operator->() const noexcept
-      requires contiguous_iterator<_It>
-      { return std::to_address(_M_current); }
+      { return *_M_current; }
 
       constexpr counted_iterator&
       operator++()
@@ -2301,20 +2154,14 @@
       iter_move(const counted_iterator& __i)
       noexcept(noexcept(ranges::iter_move(__i._M_current)))
       requires input_iterator<_It>
-      {
-	__glibcxx_assert( __i._M_length > 0 );
-	return ranges::iter_move(__i._M_current);
-      }
+      { return ranges::iter_move(__i._M_current); }
 
       template<indirectly_swappable<_It> _It2>
 	friend constexpr void
 	iter_swap(const counted_iterator& __x,
 		  const counted_iterator<_It2>& __y)
 	noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
-	{
-	  __glibcxx_assert( __x._M_length > 0 && __y._M_length > 0 );
-	  ranges::iter_swap(__x._M_current, __y._M_current);
-	}
+	{ ranges::iter_swap(__x._M_current, __y._M_current); }
 
     private:
       template<input_or_output_iterator _It2> friend class counted_iterator;
@@ -2323,17 +2170,20 @@
       iter_difference_t<_It> _M_length = 0;
     };
 
+  template<typename _It>
+    struct incrementable_traits<counted_iterator<_It>>
+    {
+      using difference_type = iter_difference_t<_It>;
+    };
+
   template<input_iterator _It>
-    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
     struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
     {
-      using pointer = conditional_t<contiguous_iterator<_It>,
-				    add_pointer_t<iter_reference_t<_It>>,
-				    void>;
+      using pointer = void;
     };
 #endif // C++20
 
-  /// @} group iterators
+  // @} group iterators
 
   template<typename _Iterator>
     auto
